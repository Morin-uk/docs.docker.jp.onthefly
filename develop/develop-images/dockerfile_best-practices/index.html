<!-- Page generated 2019-05-10 16:39:30 +0900 -->
<!-- relative link basehrefs -->

	
	
	
		
			
		
	
		
			
		
	
		
			
			


<!-- Logic for 'edit this button' -->


	

	

	

	

	

	

	

	

	


<!-- End of logic for 'edit this button' -->


<!DOCTYPE html>
<html lang="ja">

<head>
	<base href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/" />
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style type="text/css">
		@charset "UTF-8";
		[ng\:cloak],
		[ng-cloak],
		[data-ng-cloak],
		[x-ng-cloak],
		.ng-cloak,
		.x-ng-cloak,
		.ng-hide:not(.ng-hide-animate) {
			display: none !important;
		}

		ng\:form {
			display: block;
		}
	</style>
	<script type="text/javascript">
	  !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="4.0.0";
	  analytics.load("IWj9D0UpZHZdZUZX9jl98PcpBFWBnBMy");
	  analytics.page();
	  }}();
	</script>
	
	<!-- favicon -->
	<link rel="icon" type="image/x-icon" href="https://matsuand.github.io/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
	<meta name="msapplication-TileImage" content="https://matsuand.github.io/docs.docker.jp.onthefly/favicons/docs@2x.ico">
	<link rel="apple-touch-icon" type="image/x-icon" href="https://matsuand.github.io/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
	<meta property="og:image" content="https://matsuand.github.io/docs.docker.jp.onthefly/favicons/docs@2x.ico"/>
	<!-- metadata -->
	<meta property="og:type" content="website"/>
	<meta property="og:updated_time" itemprop="dateUpdated" content="2019-05-10T16:39:30+09:00"/>
	<meta property="og:image" itemprop="image primaryImageOfPage" content="https://matsuand.github.io/docs.docker.jp.onthefly/images/docs@2x.png"/>
	<meta name="twitter:card" content="summary"/>
	<meta name="twitter:domain" content="docs.docker.jp"/>
	<meta name="twitter:site" content="@docker_docs"/>
	<meta name="twitter:url" content="https://twitter.com/docker_docs"/>
	<meta name="twitter:title" itemprop="title name" content="Dockerfile 記述のベストプラクティス"/>
	<meta name="twitter:description" property="og:description" itemprop="description" content="このドキュメントは、効果的なイメージを構築するための、お勧めのベストプラクティスや方法について示します。 Docker は Dockerfile に書かれた指示を読み込んで、自動的にイメージを構築します。 これは、あらゆる命令を含んだテキストファイルであり、順に処理することで指定されたイメージを構築するために必要となるものです。 Dockerfile は所定のフォーマットにこだわっていて、特定の指示を用いることにしています。 その内容は Dockerfile リファレンス に示しています。 Docker イメージは読み取り専用のレイヤにより構成されます。 個々のレイヤは Dockerfile の各コマンドを表現しています。 レイヤは順に積み上げられ、直前のレイヤからの差分を表わします。 以下のような Dockerfile を見てみます。 FROM ubuntu:18.04 COPY . /app RUN make /app CMD..." />
	<meta name="twitter:image:src" content="https://matsuand.github.io/docs.docker.jp.onthefly/images/docs@2x.png"/>
	<meta name="twitter:image:alt" content="Docker Documentation"/>
	<meta property="article:published_time" itemprop="datePublished" content="2019-05-10T16:39:30+09:00"/>

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="keywords" content="parent image, images, dockerfile, best practices, hub, official image">
	<link rel="stylesheet" href="https://matsuand.github.io/docs.docker.jp.onthefly/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://matsuand.github.io/docs.docker.jp.onthefly/css/bootstrap.min.css">
	<link id="pygments" rel="stylesheet" href="https://matsuand.github.io/docs.docker.jp.onthefly/css/pygments/perldoc.css">
	<link id="pagestyle" rel="stylesheet" href="https://matsuand.github.io/docs.docker.jp.onthefly/css/style.css">

	<!-- Go get "Open Sans" font from Google -->
	<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
	<!-- SEO stuff -->
	<title>Dockerfile 記述のベストプラクティス | Docker Documentation</title>
<meta property="og:title" content="Dockerfile 記述のベストプラクティス" />
<meta property="og:locale" content="ja_JP" />
<meta name="description" content="Hints, tips and guidelines for writing clean, reliable Dockerfiles" />
<meta property="og:description" content="Hints, tips and guidelines for writing clean, reliable Dockerfiles" />
<link rel="canonical" href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/" />
<meta property="og:url" content="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/" />
<meta property="og:site_name" content="Docker Documentation" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"WebPage","headline":"Dockerfile 記述のベストプラクティス","description":"Hints, tips and guidelines for writing clean, reliable Dockerfiles","url":"https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/"}</script>
	<!-- END SEO STUFF -->
	
	<script language="javascript">
	// Default to assuming this is an archive and hiding some stuff
	// See js/archive.js and js/docs.js for logic relating to this
	var isArchive = true;
	var dockerVersion = 'v18.09';
	</script>
</head>
<body ng-app="Docker" ng-controller="DockerController" class="colums">
	<header>
		 <nav class="nav-secondary navbar navbar-fixed-top">
    <!-- <div class="fan"></div> -->
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="https://matsuand.github.io/docs.docker.jp.onthefly/"><img class="logo" src="https://matsuand.github.io/docs.docker.jp.onthefly/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs"></a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="search-form" id="search-div" style="visibility: hidden">
    <form class="search-form form-inline ng-pristine ng-valid" /id="searchForm" action="/docs.docker.jp.onthefly/search/">
        <input class="search-field form-control ds-input" id="st-search-input" value="" name="q" placeholder="文書内検索" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteContainer">
            <div id="autocompleteResults"></div>
        </div>
        <!-- <button type="submit" class="search-submit btn btn-default">検索</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container">
    <div id="tabs">
        <ul class="tabs" id="jsTOCHorizontal">

        </ul>
    </div>
    <div class="ctrl-right hidden-xs hidden-sm">
        <a href="javascript:void(0)" id="menu-toggle"><i class="fa fa-indent" aria-hidden="true"></i></a>
        <div class="btn-group" style="visibility: hidden">
  <button type="button" class="btn btn-default dropdown-btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Docker v18.09 (current)        <span class="caret"></span>
  </button>
  <ul class="dropdown-menu">
    <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/edge/">Docker edge</a></li><li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/v18.03/">Docker v18.03</a></li><li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/v17.12/">Docker v17.12</a></li><li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/v17.09/">Docker v17.09</a></li><li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/v17.06/">Docker v17.06</a></li><li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/v17.03/">Docker v17.03</a></li>
  </ul>
</div>

    </div>
</div>

        </div>
    </div>
</nav>

	</header>

	<div class="wrapper right-open">
		<div class="container-fluid">
			<div class="row">
				<div class="col-body">
					<main class="col-content content">
						<section class="section">
							
								
							<h1>Dockerfile 記述のベストプラクティス</h1>  <span class="reading-time" title="Estimated reading time">
  <span class="reading-time-label">読む時間の目安: </span>
  
  
    18 分
  
</span>

							
							
							
<p>このドキュメントは、効果的なイメージを構築するための、お勧めのベストプラクティスや方法について示します。</p>

<p>Docker は <code class="highlighter-rouge">Dockerfile</code> に書かれた指示を読み込んで、自動的にイメージを構築します。
これは、あらゆる命令を含んだテキストファイルであり、順に処理することで指定されたイメージを構築するために必要となるものです。
<code class="highlighter-rouge">Dockerfile</code> は所定のフォーマットにこだわっていて、特定の指示を用いることにしています。
その内容は <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder/">Dockerfile リファレンス</a> に示しています。</p>

<p>Docker イメージは読み取り専用のレイヤにより構成されます。
個々のレイヤは Dockerfile の各コマンドを表現しています。
レイヤは順に積み上げられ、直前のレイヤからの差分を表わします。
以下のような <code class="highlighter-rouge">Dockerfile</code> を見てみます。</p>

<pre><code class="language-Dockerfile">FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
</code></pre>

<p>各コマンドからは 1つずつレイヤーが生成されます。</p>

<ul>
  <li><code class="highlighter-rouge">FROM</code> Docker イメージ <code class="highlighter-rouge">ubuntu:18.04</code> からレイヤを 1 つ生成します。</li>
  <li><code class="highlighter-rouge">COPY</code> Docker クライアントのカレントディレクトリからファイルをコピーします。</li>
  <li><code class="highlighter-rouge">RUN</code> <code class="highlighter-rouge">make</code> を使ってアプリケーションをビルドします。</li>
  <li><code class="highlighter-rouge">CMD</code> コンテナー内にて実行するコマンドを指定します。</li>
</ul>

<p>イメージを実行してコンテナーが生成されると、それまであったレイヤの上に_書き込み可能やレイヤ_（”コンテナーレイヤ”）が加えられます。
実行されているコンテナーへの変更、つまり新規ファイル生成や既存ファイル編集、ファイル削除などはすべて、その薄くできあがった書き込みレイヤに書き込まれます。</p>

<p>イメージレイヤ（また Docker がイメージをどう作り保存するか）については <a href="https://matsuand.github.io/docs.docker.jp.onthefly/storage/storagedriver/">ストレージドライバーについて</a> を参照してください。</p>

<h2 id="一般的なガイドラインとアドバイス">一般的なガイドラインとアドバイス</h2>

<h3 id="はかない-ephemeral-コンテナーの生成">“はかない” (ephemeral) コンテナーの生成</h3>

<p><code class="highlighter-rouge">Dockerfile</code> によって定義されるイメージからコンテナーが作り出されますが、このコンテナーはできる限り “はかないもの”（ephemeral）と考えておくべきです。
“はかない” という語を使うのは、コンテナーが停止、破棄されて、すぐに新たなものが作り出されるからです。
最小限の構成や設定があれば、新たなものに置き換えられます。</p>

<p><em>The Twelve-factor App</em> 手法にある<a href="https://12factor.net/processes">プロセス</a>を見てみると、コンテナーの実行の仕方をステートレス（stateless）にしている理由がつかめると思います。</p>

<h3 id="ビルドコンテキストを理解する">ビルドコンテキストを理解する</h3>

<p><code class="highlighter-rouge">docker build</code> コマンドを実行したときの、カレントなワーキングディレクトリのことを <em>ビルドコンテキスト</em>（build context）と呼びます。
デフォルトで Dockerfile は、カレントなワーキングディレクトリを指すものとしていますが、ファイルフラグ（<code class="highlighter-rouge">-f</code>）を使って別のディレクトリを指定することもできます。
Regardless of where the <code class="highlighter-rouge">Dockerfile</code> actually lives, all recursive contents of files and
directories in the current directory are sent to the Docker daemon as the build context.</p>

<blockquote>
  <p>ビルドコンテキストの例</p>

  <p>ビルドコンテキストとするディレクトリを生成してそこに <code class="highlighter-rouge">cd</code> で移動します。
テキストファイル <code class="highlighter-rouge">hello</code> に “hello” と書き込み、Dockerfile 上でそのファイルに対して <code class="highlighter-rouge">cat</code> コマンドを与えるようにします。
ビルドコンテキスト（<code class="highlighter-rouge">.</code>）の中からイメージをビルドします。</p>

  <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir myproject <span class="o">&amp;&amp;</span> <span class="nb">cd </span>myproject
<span class="nb">echo</span> <span class="s2">"hello"</span> <span class="o">&gt;</span> hello
<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"FROM busybox</span><span class="se">\n</span><span class="s2">COPY /hello /</span><span class="se">\n</span><span class="s2">RUN cat /hello"</span> <span class="o">&gt;</span> Dockerfile
docker build <span class="nt">-t</span> helloapp:v1 <span class="nb">.</span>
</code></pre></div>  </div>

  <p><code class="highlighter-rouge">Dockerfile</code> と <code class="highlighter-rouge">hello</code> をそれぞれ別のディレクトリに移動させて、（上でビルドした際のキャッシュには頼らずに）2 つめのイメージをビルドします。
Dockerfile に対して <code class="highlighter-rouge">-f</code> を使い、ビルドコンテキストとなるディレクトリを指定します。</p>

  <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir <span class="nt">-p</span> dockerfiles context
mv Dockerfile dockerfiles <span class="o">&amp;&amp;</span> mv hello context
docker build <span class="nt">--no-cache</span> <span class="nt">-t</span> helloapp:v2 <span class="nt">-f</span> dockerfiles/Dockerfile context
</code></pre></div>  </div>
</blockquote>

<p>Inadvertently including files that are not necessary for building an image
results in a larger build context and larger image size. This can increase the
time to build the image, time to pull and push it, and the container runtime
size. To see how big your build context is, look for a message like this when
building your <code class="highlighter-rouge">Dockerfile</code>:</p>

<pre><code class="language-none">Sending build context to Docker daemon  187.8MB
</code></pre>

<h3 id="stdin-を通じた-dockerfile-のパイプ"><code class="highlighter-rouge">stdin</code> を通じた Dockerfile のパイプ</h3>

<p>Docker has the ability to build images by piping <code class="highlighter-rouge">Dockerfile</code> through <code class="highlighter-rouge">stdin</code>
with a <em>local or remote build context</em>. Piping a <code class="highlighter-rouge">Dockerfile</code> through <code class="highlighter-rouge">stdin</code>
can be useful to perform one-off builds without writing a Dockerfile to disk,
or in situations where the <code class="highlighter-rouge">Dockerfile</code> is generated, and should not persist
afterwards.</p>

<blockquote>
  <p>The examples in this section use <a href="http://tldp.org/LDP/abs/html/here-docs.html">here documents</a>
for convenience, but any method to provide the <code class="highlighter-rouge">Dockerfile</code> on <code class="highlighter-rouge">stdin</code> can be
used.</p>

  <p>For example, the following commands are equivalent:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nt">-e</span> <span class="s1">'FROM busybox\nRUN echo "hello world"'</span> | docker build -
</code></pre></div>  </div>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build -<span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
FROM busybox
RUN echo "hello world"
</span><span class="no">EOF
</span></code></pre></div>  </div>

  <p>You can substitute the examples with your preferred approach, or the approach
that best fits your use-case.</p>
</blockquote>

<h4 id="build-an-image-using-a-dockerfile-from-stdin-without-sending-build-context">Build an image using a Dockerfile from stdin, without sending build context</h4>

<p>Use this syntax to build an image using a <code class="highlighter-rouge">Dockerfile</code> from <code class="highlighter-rouge">stdin</code>, without
sending additional files as build context. The hyphen (<code class="highlighter-rouge">-</code>) takes the position
of the <code class="highlighter-rouge">PATH</code>, and instructs Docker to read the build context (which only
contains a <code class="highlighter-rouge">Dockerfile</code>) from <code class="highlighter-rouge">stdin</code> instead of a directory:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="o">[</span>OPTIONS] -
</code></pre></div></div>

<p>The following example builds an image using a <code class="highlighter-rouge">Dockerfile</code> that is passed through
<code class="highlighter-rouge">stdin</code>. No files are sent as build context to the daemon.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> myimage:latest -<span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
FROM busybox
RUN echo "hello world"
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Omitting the build context can be useful in situations where your <code class="highlighter-rouge">Dockerfile</code>
does not require files to be copied into the image, and improves the build-speed,
as no files are sent to the daemon.</p>

<p>If you want to improve the build-speed by excluding <em>some</em> files from the build-
context, refer to <a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#exclude-with-dockerignore">exclude with .dockerignore</a>.</p>

<blockquote>
  <p><strong>Note</strong>: Attempting to build a Dockerfile that uses <code class="highlighter-rouge">COPY</code> or <code class="highlighter-rouge">ADD</code> will fail
if this syntax is used. The following example illustrates this:</p>

  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># create a directory to work in</span>
mkdir example
<span class="nb">cd </span>example

<span class="c"># create an example file</span>
touch somefile.txt

docker build <span class="nt">-t</span> myimage:latest -<span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
FROM busybox
COPY somefile.txt .
RUN cat /somefile.txt
</span><span class="no">EOF

</span><span class="c"># observe that the build fails</span>
...
Step 2/3 : COPY somefile.txt <span class="nb">.</span>
COPY failed: stat /var/lib/docker/tmp/docker-builder249218248/somefile.txt: no such file or directory
</code></pre></div>  </div>
</blockquote>

<h4 id="build-from-a-local-build-context-using-a-dockerfile-from-stdin">Build from a local build context, using a Dockerfile from stdin</h4>

<p>Use this syntax to build an image using files on your local filesystem, but using
a <code class="highlighter-rouge">Dockerfile</code> from <code class="highlighter-rouge">stdin</code>. The syntax uses the <code class="highlighter-rouge">-f</code> (or <code class="highlighter-rouge">--file</code>) option to
specify the <code class="highlighter-rouge">Dockerfile</code> to use, using a hyphen (<code class="highlighter-rouge">-</code>) as filename to instruct
Docker to read the <code class="highlighter-rouge">Dockerfile</code> from <code class="highlighter-rouge">stdin</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="o">[</span>OPTIONS] <span class="nt">-f-</span> PATH
</code></pre></div></div>

<p>The example below uses the current directory (<code class="highlighter-rouge">.</code>) as the build context, and builds
an image using a <code class="highlighter-rouge">Dockerfile</code> that is passed through <code class="highlighter-rouge">stdin</code> using a <a href="http://tldp.org/LDP/abs/html/here-docs.html">here
document</a>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># create a directory to work in</span>
mkdir example
<span class="nb">cd </span>example

<span class="c"># create an example file</span>
touch somefile.txt

<span class="c"># build an image using the current directory as context, and a Dockerfile passed through stdin</span>
docker build <span class="nt">-t</span> myimage:latest <span class="nt">-f-</span> <span class="nb">.</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
FROM busybox
COPY somefile.txt .
RUN cat /somefile.txt
</span><span class="no">EOF
</span></code></pre></div></div>

<h4 id="build-from-a-remote-build-context-using-a-dockerfile-from-stdin">Build from a remote build context, using a Dockerfile from stdin</h4>

<p>Use this syntax to build an image using files from a remote <code class="highlighter-rouge">git</code> repository,
using a <code class="highlighter-rouge">Dockerfile</code> from <code class="highlighter-rouge">stdin</code>. The syntax uses the <code class="highlighter-rouge">-f</code> (or <code class="highlighter-rouge">--file</code>) option to
specify the <code class="highlighter-rouge">Dockerfile</code> to use, using a hyphen (<code class="highlighter-rouge">-</code>) as filename to instruct
Docker to read the <code class="highlighter-rouge">Dockerfile</code> from <code class="highlighter-rouge">stdin</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="o">[</span>OPTIONS] <span class="nt">-f-</span> PATH
</code></pre></div></div>

<p>This syntax can be useful in situations where you want to build an image from a
repository does not contain a <code class="highlighter-rouge">Dockerfile</code>, or if you want to build with a custom
<code class="highlighter-rouge">Dockerfile</code>, without maintaining your own fork of the repository.</p>

<p>The example below builds an image using a <code class="highlighter-rouge">Dockerfile</code> from <code class="highlighter-rouge">stdin</code>, and adds
the <code class="highlighter-rouge">README.md</code> file from the <a href="https://github.com/docker-library/hello-world">“hello-world” Git repository on GitHub</a>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> myimage:latest <span class="nt">-f-</span> https://github.com/docker-library/hello-world.git <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
FROM busybox
COPY README.md .
</span><span class="no">EOF
</span></code></pre></div></div>

<blockquote>
  <p><strong>Under the hood</strong></p>

  <p>When building an image using a remote Git repository as build context, Docker
performs a <code class="highlighter-rouge">git clone</code> of the repository on the local machine, and sends
those files as build context to the daemon. This feature requires <code class="highlighter-rouge">git</code> to be
installed on the host where you run the <code class="highlighter-rouge">docker build</code> command.</p>
</blockquote>

<h3 id="exclude-with-dockerignore">Exclude with .dockerignore</h3>

<p>To exclude files not relevant to the build (without restructuring your source
repository) use a <code class="highlighter-rouge">.dockerignore</code> file. This file supports exclusion patterns
similar to <code class="highlighter-rouge">.gitignore</code> files. For information on creating one, see the
<a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#dockerignore-file">.dockerignore file</a>.</p>

<h3 id="use-multi-stage-builds">Use multi-stage builds</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/multistage-build/">Multi-stage builds</a> allow you to drastically reduce the
size of your final image, without struggling to reduce the number of intermediate
layers and files.</p>

<p>Because an image is built during the final stage of the build process, you can
minimize image layers by <a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#leverage-build-cache">leveraging build cache</a>.</p>

<p>For example, if your build contains several layers, you can order them from the
less frequently changed (to ensure the build cache is reusable) to the more
frequently changed:</p>

<ul>
  <li>
    <p>Install tools you need to build your application</p>
  </li>
  <li>
    <p>Install or update library dependencies</p>
  </li>
  <li>
    <p>Generate your application</p>
  </li>
</ul>

<p>A Dockerfile for a Go application could look like:</p>

<pre><code class="language-Dockerfile">FROM golang:1.11-alpine AS build

# Install tools required for project
# Run `docker build --no-cache .` to update dependencies
RUN apk add --no-cache git
RUN go get github.com/golang/dep/cmd/dep

# List project dependencies with Gopkg.toml and Gopkg.lock
# These layers are only re-built when Gopkg files are updated
COPY Gopkg.lock Gopkg.toml /go/src/project/
WORKDIR /go/src/project/
# Install library dependencies
RUN dep ensure -vendor-only

# Copy the entire project and build it
# This layer is rebuilt when a file changes in the project directory
COPY . /go/src/project/
RUN go build -o /bin/project

# This results in a single layer image
FROM scratch
COPY --from=build /bin/project /bin/project
ENTRYPOINT ["/bin/project"]
CMD ["--help"]
</code></pre>

<h3 id="不要なパッケージをインストールしない">不要なパッケージをインストールしない</h3>

<p>複雑さ、依存関係、ファイルサイズ、構築時間をそれぞれ減らすためには、余分な、または必須ではない「あった方が良いだろう」程度のパッケージをインストールすべきではありません。
例えば、データベースイメージであればテキストエディターは不要でしょう。</p>

<h3 id="アプリケーションの分割">アプリケーションの分割</h3>

<p>1 つのコンテナーにとって関心のあることといえば、ただ 1 つです。
アプリケーションを複数のコンテナーに分けることにより、スケールアウトやコンテナーの再利用がしやすくなります。
たとえばウェブアプリケーションが３つの独立したコンテナーにより成り立っているとします。
それらは個々のイメージを持つものとなり、それぞれに分かれてウェブアプリケーション、データベース、メモリキャッシュを管理するようになります。</p>

<p>個々のコンテナーを１つのプロセスのみに限定して割り当てることは、優れた経験則となることがありますが、決して厳密な規則というわけでもありません。
たとえばコンテナーは<a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/run/#/specifying-an-init-process">初期プロセスにおいて起動</a>することが可能であり、プログラムの中には都合に応じて追加のプロセスを起動するようなものもあります。
例をあげると、<a href="http://www.celeryproject.org/">Celery</a> はワーカープロセスを複数起動し、<a href="https://httpd.apache.org/">Apache</a> はリクエストごとにプロセスを生成します。</p>

<p>コンテナーはできる限りすっきりとモジュラー化されるように、適切な判断をしてください。
コンテナーが互いに依存している場合は、<a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/userguide/networking/&gt;">Docker container ネットワーク</a>を用いることで、コンテナー間の通信を確実に行うことができます。</p>

<h3 id="レイヤ数は最小に">レイヤ数は最小に</h3>

<p>In older versions of Docker, it was important that you minimized the number of
layers in your images to ensure they were performant. The following features
were added to reduce this limitation:</p>

<ul>
  <li>
    <p>Only the instructions <code class="highlighter-rouge">RUN</code>, <code class="highlighter-rouge">COPY</code>, <code class="highlighter-rouge">ADD</code> create layers. Other instructions
create temporary intermediate images, and do not increase the size of the build.</p>
  </li>
  <li>
    <p>Where possible, use <a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/multistage-build/">multi-stage builds</a>, and only copy
the artifacts you need into the final image. This allows you to include tools
and debug information in your intermediate build stages without increasing the
size of the final image.</p>
  </li>
</ul>

<h3 id="複数行にわたる引数は並びを適切に">複数行にわたる引数は並びを適切に</h3>

<p>複数行にわたる引数は、できるなら後々の変更を容易にするために、その並びはアルファベット順にしましょう。
そうしておけば、パッケージを重複指定することはなくなり、一覧の変更も簡単になります。
プルリクエストを読んだりレビューしたりすることも、さらに楽になります。
バックスラッシュ（<code class="highlighter-rouge">\</code>） の前に空白を含めておくことも同様です。</p>

<p>以下は <a href="https://github.com/docker-library/buildpack-deps"><code class="highlighter-rouge">buildpack-deps</code> イメージ</a> の記述例です。</p>

<pre><code class="language-Dockerfile">RUN apt-get update &amp;&amp; apt-get install -y \
  bzr \
  cvs \
  git \
  mercurial \
  subversion
</code></pre>

<h3 id="ビルドキャッシュの利用">ビルドキャッシュの利用</h3>

<p>イメージの構築時に Docker は <code class="highlighter-rouge">Dockerfile</code> 内に示されている命令を記述順に実行していきます。
個々の命令が検査される際に Docker は、既存イメージのキャッシュが再利用できるかどうかを調べます。
そこでは新たな（同じ）イメージを作ることはしません。</p>

<p>キャッシュをまったく使いたくない場合は <code class="highlighter-rouge">docker build</code> コマンドに <code class="highlighter-rouge">--no-cache=true</code> オプションをつけて実行します。
一方で Docker のキャッシュを利用する場合、Docker が適切なイメージを見つけた上で、どのようなときにキャッシュを利用し、どのようなときには利用しないのかを理解しておくことが必要です。
Docker が従っている規則は以下のとおりです。</p>

<ul>
  <li>
    <p>キャッシュ内にすでに存在している親イメージから処理を始めます。
そのベースとなるイメージから派生した子イメージに対して、次の命令が合致するかどうかが比較され、子イメージのいずれかが同一の命令によって構築されているかを確認します。
そのようなものが存在しなければ、キャッシュは無効になります。</p>
  </li>
  <li>
    <p>ほとんどの場合 <code class="highlighter-rouge">Dockerfile</code> 内の命令と子イメージのどれかを単純に比較するだけで十分です。
しかし命令によっては、多少の検査や解釈が必要となるものもあります。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ADD</code> 命令や <code class="highlighter-rouge">COPY</code> 命令では、イメージに含まれるファイルの内容が検査され、個々のファイルについてチェックサムが計算されます。
この計算において、ファイルの最終更新時刻、最終アクセス時刻は考慮されません。
キャッシュを探す際に、このチェックサムと既存イメージのチェックサムが比較されます。
ファイル内の何かが変更になったとき、たとえばファイル内容やメタデータが変わっていれば、キャッシュは無効になります。</p>
  </li>
</ul>

<p><code class="highlighter-rouge">ADD</code> と <code class="highlighter-rouge">COPY</code> 以外のコマンドの場合、キャッシュのチェックは、コンテナー内のファイル内容を見ることはなく、それによってキャッシュと合致しているかどうかが決定されるわけでありません。
  たとえば <code class="highlighter-rouge">RUN apt-get -y update</code> コマンドの処理が行われる際には、コンテナー内にて更新されたファイルは、キャッシュが合致するかどうかの判断のために用いられません。
  この場合にはコマンド文字列そのものが、キャッシュの合致判断に用いられます。</p>

<p>キャッシュが無効化されると、以降の <code class="highlighter-rouge">Dockerfile</code> 命令ではキャッシュは使われず、新しいイメージを生成します。</p>

<h2 id="dockerfile-コマンド">Dockerfile コマンド</h2>

<p>These recommendations are designed to help you create an efficient and
maintainable <code class="highlighter-rouge">Dockerfile</code>.</p>

<h3 id="from">FROM</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#from">Dockerfile リファレンスの FROM コマンド</a></p>

<p>イメージのベースは、できるだけ現時点での公式リポジトリを利用してください。
<a href="https://hub.docker.com/_/alpine/">Alpine イメージ</a> がお勧めです。
このイメージはしっかりと管理されていて、充実した Linux ディストリビューションであるにもかかわらず、非常にコンパクトなものになっています（現在 5 MB 以下）。</p>

<h3 id="label">LABEL</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/config/labels-custom-metadata.md">オブジェクトラベルを理解する</a></p>

<p>イメージにラベルを追加するのは、プロジェクト内でのイメージ管理をしやすくしたり、ライセンス情報の記録や自動化の助けとするなど、さまざまな目的があります。
ラベルを指定するには、 <code class="highlighter-rouge">LABEL</code> で始まる行を追加して、そこにキーと値のペア（key-value pair）をいくつか設定します。
以下に示す例は、いずれも正しい構文です。
説明をコメントとしてつけています。</p>

<blockquote>
  <p>文字列に空白が含まれる場合は、引用符でくくるか、<strong>あるいは</strong>エスケープする必要があります。
文字列内に引用符がある場合も、同様にエスケープしてください。</p>
</blockquote>

<pre><code class="language-Dockerfile"># 個々にラベルを設定
LABEL com.example.version="0.0.1-beta"
LABEL vendor1="ACME Incorporated"
LABEL vendor2=ZENITH\ Incorporated
LABEL com.example.release-date="2015-02-12"
LABEL com.example.version.is-production=""
</code></pre>

<p>An image can have more than one label. Prior to Docker 1.10, it was recommended
to combine all labels into a single <code class="highlighter-rouge">LABEL</code> instruction, to prevent extra layers
from being created. This is no longer necessary, but combining labels is still
supported.</p>

<pre><code class="language-Dockerfile"># 1行でラベルを設定
LABEL com.example.version="0.0.1-beta" com.example.release-date="2015-02-12"
</code></pre>

<p>上は以下のように書くこともできます。</p>

<pre><code class="language-Dockerfile"># 複数のラベルを一度に設定、ただし行継続の文字を使い、長い文字列を改行する
LABEL vendor=ACME\ Incorporated \
      com.example.is-beta= \
      com.example.is-production="" \
      com.example.version="0.0.1-beta" \
      com.example.release-date="2015-02-12"
</code></pre>

<p>See <a href="https://matsuand.github.io/docs.docker.jp.onthefly/config/labels-custom-metadata.md">Understanding object labels</a>
for guidelines about acceptable label keys and values. For information about
querying labels, refer to the items related to filtering in <a href="https://matsuand.github.io/docs.docker.jp.onthefly/config/labels-custom-metadata.md#managing-labels-on-objects">Managing labels on
objects</a>. See also
<a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder/#label">LABEL</a> in the Dockerfile reference.</p>

<h3 id="run">RUN</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#run">Dockerfile リファレンスの RUN コマンド</a></p>

<p><code class="highlighter-rouge">RUN</code> コマンドが複数行にわたって長く複雑になるようであれば、バックスラッシュを使って行を分けてください。
<code class="highlighter-rouge">Dockerfile</code> を読みやすく理解しやすく、そして保守しやすくするためです。</p>

<h4 id="apt-get">apt-get</h4>

<p>おそらく <code class="highlighter-rouge">RUN</code> において一番利用する使い方が <code class="highlighter-rouge">apt-get</code> アプリケーションの実行です。
<code class="highlighter-rouge">RUN apt-get</code> はパッケージをインストールするものであるため、注意点がいくつかあります。</p>

<p><code class="highlighter-rouge">RUN apt-get upgrade</code> や <code class="highlighter-rouge">dist-upgrade</code> の実行は避けてください。
親イメージに含まれる重要パッケージは、<a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/run.md#security-configuration">権限が与えられていないコンテナー</a>内ではほとんど更新できないからです。
親イメージ内のパッケージが古くなっていたら、開発者に連絡をとってください。
<code class="highlighter-rouge">foo</code> というパッケージを更新する必要があれば <code class="highlighter-rouge">apt-get install -y foo</code> を利用してください。
これによってパッケージは自動的に更新されます。</p>

<p><code class="highlighter-rouge">RUN apt-get update</code> と <code class="highlighter-rouge">apt-get install</code> は、同一の <code class="highlighter-rouge">RUN</code> コマンド内にて同時実行するようにしてください。
たとえば以下のようにします。</p>

<pre><code class="language-Dockerfile">RUN apt-get update &amp;&amp; apt-get install -y \
    package-bar \
    package-baz \
    package-foo
</code></pre>

<p>１つの <code class="highlighter-rouge">RUN</code> コマンド内で <code class="highlighter-rouge">apt-get update</code> だけを使うとキャッシュに問題が発生し、その後の <code class="highlighter-rouge">apt-get install</code> コマンドが失敗します。
たとえば Dockerfile を以下のように記述したとします。</p>

<pre><code class="language-Dockerfile">FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install -y curl
</code></pre>

<p>イメージが構築されると、レイヤーがすべて Docker のキャッシュに入ります。
この次に <code class="highlighter-rouge">apt-get install</code> を編集して別のパッケージを追加したとします。</p>

<pre><code class="language-Dockerfile">FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install -y curl nginx
</code></pre>

<p>Docker は当初のコマンドと修正後のコマンドを見て、同一のコマンドであると判断するので、前回の処理において作られたキャッシュを再利用します。
キャッシュされたものを利用して処理が行われるわけですから、結果として <code class="highlighter-rouge">apt-get update</code> は実行されません。
<code class="highlighter-rouge">apt-get update</code> が実行されないということは、つまり <code class="highlighter-rouge">curl</code> にしても <code class="highlighter-rouge">nginx</code> にしても、古いバージョンのまま利用する可能性が出てくるということです。</p>

<p><code class="highlighter-rouge">RUN apt-get update &amp;&amp; apt-get install -y</code> というコマンドにすると、 Dockerfile が確実に最新バージョンをインストールしてくれるものとなり、さらにコードを書いたり手作業を加えたりする必要がなくなります。
これは「キャッシュバスティング（cache busting）」と呼ばれる技術です。
この技術は、パッケージのバージョンを指定することによっても利用することができます。
これはバージョンピニング（version pinning）というものです。
以下に例を示します。</p>

<pre><code class="language-Dockerfile">RUN apt-get update &amp;&amp; apt-get install -y \
    package-bar \
    package-baz \
    package-foo=1.3.*
</code></pre>

<p>バージョンピニングでは、キャッシュにどのようなイメージがあろうとも、指定されたバージョンを使ってビルドが行われます。
この手法を用いれば、そのパッケージの最新版に、思いもよらない変更が加わっていたとしても、ビルド失敗を回避できることもあります。</p>

<p>以下の <code class="highlighter-rouge">RUN</code> コマンドはきれいに整えられていて <code class="highlighter-rouge">apt-get</code> の推奨する利用方法を示しています。</p>

<pre><code class="language-Dockerfile">RUN apt-get update &amp;&amp; apt-get install -y \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.* \
 &amp;&amp; rm -rf /var/lib/apt/lists/*
</code></pre>

<p><code class="highlighter-rouge">s3cmd</code> のコマンド行は、バージョン <code class="highlighter-rouge">1.1.*</code> を指定しています。
以前に作られたイメージが古いバージョンを使っていたとしても、新たなバージョンの指定により <code class="highlighter-rouge">apt-get update</code> のキャッシュバスティングが働いて、確実に新バージョンがインストールされるようになります。
パッケージを各行に分けて記述しているのは、パッケージを重複して書くようなミスを防ぐためです。</p>

<p>apt キャッシュをクリーンアップし <code class="highlighter-rouge">/var/lib/apt/lists</code> を削除するのは、イメージサイズを小さくするためです。
そもそも apt キャッシュはレイヤー内に保存されません。
<code class="highlighter-rouge">RUN</code> コマンドを <code class="highlighter-rouge">apt-get update</code> から始めているので、<code class="highlighter-rouge">apt-get install</code> の前に必ずパッケージのキャッシュが更新されることになります。</p>

<blockquote>
  <p>公式の Debian と Ubuntu のイメージは<a href="https://github.com/moby/moby/blob/03e2923e42446dbb830c654d0eec323a0b4ef02a/contrib/mkimage/debootstrap#L82-L105">自動的に <code class="highlighter-rouge">apt-get clean</code> を実行する</a>ので、明示的にこのコマンドを実行する必要はありません。</p>
</blockquote>

<h4 id="パイプの利用">パイプの利用</h4>

<p><code class="highlighter-rouge">RUN</code> コマンドの中には、その出力をパイプを使って他のコマンドへ受け渡すことを前提としているものがあります。
そのときにはパイプを行う文字（ <code class="highlighter-rouge">|</code> ）を使います。
たとえば以下のような例があります。</p>

<pre><code class="language-Dockerfile">RUN wget -O - https://some.site | wc -l &gt; /number
</code></pre>

<p>Docker はこういったコマンドを <code class="highlighter-rouge">/bin/sh -c</code> というインタープリター実行により実現します。
正常処理されたかどうかは、パイプの最後の処理の終了コードにより評価されます。
上の例では、このビルド処理が成功して新たなイメージが生成されるかどうかは、<code class="highlighter-rouge">wc -l</code> コマンドの成功にかかっています。
つまり <code class="highlighter-rouge">wget</code> コマンドが成功するかどうかは関係がありません。</p>

<p>パイプ内のどの段階でも、エラーが発生したらコマンド失敗としたい場合は、頭に <code class="highlighter-rouge">set -o pipefail &amp;&amp;</code> をつけて実行します。
こうしておくと、予期しないエラーが発生して、それに気づかずにビルドされてしまう、といったことはなくなります。
たとえば以下です。</p>

<pre><code class="language-Dockerfile">RUN set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number
</code></pre>

<blockquote>
  <p>すべてのシェルが <code class="highlighter-rouge">-o pipefail</code> オプションをサポートしているわけではありません。
その場合（例えば Debian ベースのイメージにおけるデフォルトシェル <code class="highlighter-rouge">dash</code> である場合）、<code class="highlighter-rouge">RUN</code> コマンドにおける <strong>exec</strong> 形式の利用を考えてみてください。
これは <code class="highlighter-rouge">pipefail</code> オプションをサポートしているシェルを明示的に指示するものです。
たとえば以下です。</p>

  <pre><code class="language-Dockerfile">RUN ["/bin/bash", "-c", "set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number"]
</code></pre>
</blockquote>

<h3 id="cmd">CMD</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#cmd">Dockerfile リファレンスの CMD コマンド</a></p>

<p><code class="highlighter-rouge">CMD</code> コマンドは、イメージ内に含まれるソフトウェアを実行するために用いるもので、引数を指定して実行します。
<code class="highlighter-rouge">CMD</code> はほぼ、<code class="highlighter-rouge">CMD ["実行モジュール名", "引数1", "引数2"…]</code> の形式をとります。
Apache や Rails のようにサービスをともなうイメージに対しては、たとえば <code class="highlighter-rouge">CMD ["apache2","-DFOREGROUND"]</code> といったコマンド実行になります。
実際にサービスベースのイメージに対しては、この実行形式が推奨されます。</p>

<p>上記以外では、<code class="highlighter-rouge">CMD</code> に対して bash、python、perl などインタラクティブシェルを与えることが行われます。
たとえば <code class="highlighter-rouge">CMD ["perl", "-de0"]</code>、<code class="highlighter-rouge">CMD ["python"]</code>、<code class="highlighter-rouge">CMD ["php", "-a"]</code> といった具合です。
この実行形式を利用するということは、たとえば <code class="highlighter-rouge">docker run -it python</code> というコマンドを実行したときに、指定したシェルの中に入り込んで、処理を進めていくことを意味します。
<code class="highlighter-rouge">CMD</code> と <code class="highlighter-rouge">ENTRYPOINT</code> を組み合わせて用いる <code class="highlighter-rouge">CMD ["引数", "引数"]</code> という実行形式がありますが、これを利用するのはまれです。
開発者自身や利用者にとって <code class="highlighter-rouge">ENTRYPOINT</code> がどのように動作するのかが十分に分かっていないなら、用いないようにしましょう。</p>

<h3 id="expose">EXPOSE</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#expose">Dockerfile リファレンスの EXPOSE コマンド</a></p>

<p><code class="highlighter-rouge">EXPOSE</code> コマンドは、コンテナーが接続のためにリッスンするポートを指定します。
当然のことながらアプリケーションにおいては、標準的なポートを利用します。
たとえば Apache ウェブサーバーを含んでいるイメージに対しては <code class="highlighter-rouge">EXPOSE 80</code> を使います。
また MongoDB を含んでいれば <code class="highlighter-rouge">EXPOSE 27017</code> を使うことになります。</p>

<p>外部からアクセスできるようにするため、これを実行するユーザーは <code class="highlighter-rouge">docker run</code> にフラグをつけて実行します。
そのフラグとは、指定されているポートを、自分が取り決めるどのようなポートに割り当てるかを指示するものです。
Docker のリンク機能においては環境変数が利用できます。
受け側のコンテナーが提供元をたどることができるようにするものです（例: <code class="highlighter-rouge">MYSQL_PORT_3306_TCP</code> ）。</p>

<h3 id="env">ENV</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#env">Dockerfile リファレンスの ENV コマンド</a></p>

<p>新しいソフトウェアに対しては <code class="highlighter-rouge">ENV</code> を用いれば簡単にそのソフトウェアを実行できます。
コンテナーがインストールするソフトウェアに必要な環境変数 <code class="highlighter-rouge">PATH</code> を、この <code class="highlighter-rouge">ENV</code> を使って更新します。
たとえば <code class="highlighter-rouge">ENV PATH /usr/local/nginx/bin:$PATH</code> を実行すれば、 <code class="highlighter-rouge">CMD ["nginx"]</code> が確実に動作するようになります。</p>

<p><code class="highlighter-rouge">ENV</code> コマンドは、必要となる環境変数を設定するときにも利用します。
たとえば Postgres の <code class="highlighter-rouge">PGDATA</code> のように、コンテナー化したいサービスに固有の環境変数が設定できます。</p>

<p>また <code class="highlighter-rouge">ENV</code> は普段利用している各種バージョン番号を設定しておくときにも利用されます。
これによってバージョンを混同することなく、管理が容易になります。
たとえば以下がその例です。</p>

<pre><code class="language-Dockerfile">ENV PG_MAJOR 9.3
ENV PG_VERSION 9.3.4
RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …
ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH
</code></pre>

<p>プログラムにおける（ハードコーディングではない）定数定義と同じことで、この方法をとっておくのが便利です。
ただ１つの <code class="highlighter-rouge">ENV</code> コマンドを変更するだけで、コンテナー内のソフトウェアバージョンは、いとも簡単に変えてしまうことができるからです。</p>

<p>Each <code class="highlighter-rouge">ENV</code> line creates a new intermediate layer, just like <code class="highlighter-rouge">RUN</code> commands. This
means that even if you unset the environment variable in a future layer, it
still persists in this layer and its value can be dumped. You can test this by
creating a Dockerfile like the following, and then building it.</p>

<pre><code class="language-Dockerfile">FROM alpine
ENV ADMIN_USER="mark"
RUN echo $ADMIN_USER &gt; ./mark
RUN unset ADMIN_USER
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nb">test </span>sh <span class="nt">-c</span> <span class="s1">'echo $ADMIN_USER'</span>

mark
</code></pre></div></div>

<p>To prevent this, and really unset the environment variable, use a <code class="highlighter-rouge">RUN</code> command
with shell commands, to set, use, and unset the variable all in a single layer.
You can separate your commands with <code class="highlighter-rouge">;</code> or <code class="highlighter-rouge">&amp;&amp;</code>. If you use the second method,
and one of the commands fails, the <code class="highlighter-rouge">docker build</code> also fails. This is usually a
good idea. Using <code class="highlighter-rouge">\</code> as a line continuation character for Linux Dockerfiles
improves readability. You could also put all of the commands into a shell script
and have the <code class="highlighter-rouge">RUN</code> command just run that shell script.</p>

<pre><code class="language-Dockerfile">FROM alpine
RUN export ADMIN_USER="mark" \
    &amp;&amp; echo $ADMIN_USER &gt; ./mark \
    &amp;&amp; unset ADMIN_USER
CMD sh
</code></pre>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nb">test </span>sh <span class="nt">-c</span> <span class="s1">'echo $ADMIN_USER'</span>

</code></pre></div></div>

<h3 id="add-と-copy">ADD と COPY</h3>

<ul>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#add">Dockerfile リファレンスの ADD コマンド</a></li>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#copy">Dockerfile リファレンスの COPY コマンド</a></li>
</ul>

<p><code class="highlighter-rouge">ADD</code> と <code class="highlighter-rouge">COPY</code> の機能は似ていますが、一般的には <code class="highlighter-rouge">COPY</code> が選ばれます。
それは <code class="highlighter-rouge">ADD</code> よりも機能がはっきりしているからです。
<code class="highlighter-rouge">COPY</code> は単に、基本的なコピー機能を使ってローカルファイルをコンテナーにコピーするだけです。
一方 <code class="highlighter-rouge">ADD</code> には特定の機能（ローカルでの tar 展開やリモート URL サポート）があり、これはすぐにわかるものではありません。
結局 <code class="highlighter-rouge">ADD</code> の最も適切な利用場面は、ローカルの tar ファイルを自動的に展開してイメージに書き込むときです。
たとえば <code class="highlighter-rouge">ADD rootfs.tar.xz /</code> といったコマンドになります。</p>

<p><code class="highlighter-rouge">Dockerfile</code> 内の複数ステップにおいて異なるファイルをコピーするときには、一度にすべてをコピーするのではなく、<code class="highlighter-rouge">COPY</code> を使って個別にコピーしてください。
こうしておくと、個々のステップに対するキャッシュのビルドは最低限に抑えることができます。
つまり指定されているファイルが変更になったときのみキャッシュが無効化されます（そのステップは再実行されます）。</p>

<p>例</p>

<pre><code class="language-Dockerfile">COPY requirements.txt /tmp/
RUN pip install --requirement /tmp/requirements.txt
COPY . /tmp/
</code></pre>

<p><code class="highlighter-rouge">RUN</code> コマンドのステップより前に <code class="highlighter-rouge">COPY . /tmp/</code> を実行していたとしたら、それに比べて上の例はキャッシュ無効化の可能性が低くなっています。</p>

<p>イメージサイズの問題があるので、<code class="highlighter-rouge">ADD</code> を用いてリモート URL からパッケージを取得することはやめてください。
かわりに <code class="highlighter-rouge">curl</code> や <code class="highlighter-rouge">wget</code> を使ってください。
こうしておくことで、ファイルを取得し展開した後や、イメージ内の他のレイヤにファイルを加える必要がないのであれば、その後にファイルを削除することができます。
たとえば以下に示すのは、やってはいけない例です。</p>

<pre><code class="language-Dockerfile">ADD http://example.com/big.tar.xz /usr/src/things/
RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
RUN make -C /usr/src/things all
</code></pre>

<p>そのかわり、次のように記述します。</p>

<pre><code class="language-Dockerfile">RUN mkdir -p /usr/src/things \
    &amp;&amp; curl -SL http://example.com/big.tar.xz \
    | tar -xJC /usr/src/things \
    &amp;&amp; make -C /usr/src/things all
</code></pre>

<p><code class="highlighter-rouge">ADD</code> の自動展開機能を必要としないもの（ファイルやディレクトリ）に対しては、常に <code class="highlighter-rouge">COPY</code> を使うようにしてください。</p>

<h3 id="entrypoint">ENTRYPOINT</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#entrypoint">Dockerfile リファレンスの ENTRYPOINT コマンド</a></p>

<p><code class="highlighter-rouge">ENTRYPOINT</code> の最適な利用方法は、イメージに対してメインのコマンドを設定することです。
これを設定すると、イメージをそのコマンドそのものであるかのようにして実行できます（その次に <code class="highlighter-rouge">CMD</code> を使ってデフォルトフラグを指定します）。</p>

<p>コマンドラインツール <code class="highlighter-rouge">s3cmd</code> のイメージ例から始めます。</p>

<pre><code class="language-Dockerfile">ENTRYPOINT ["s3cmd"]
CMD ["--help"]
</code></pre>

<p>このイメージが実行されると、コマンドのヘルプが表示されます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run s3cmd
</code></pre></div></div>

<p>あるいは適正なパラメーターを指定してコマンドを実行します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run s3cmd <span class="nb">ls </span>s3://mybucket
</code></pre></div></div>

<p>このコマンドのようにして、イメージ名がバイナリへの参照としても使えるので便利です。</p>

<p><code class="highlighter-rouge">ENTRYPOINT</code> コマンドはヘルパースクリプトとの組み合わせにより利用することもできます。
そのスクリプトは、上記のコマンド例と同じように機能させられます。
たとえ対象ツールの起動に複数ステップを要するような場合でも、それが可能です。</p>

<p>For example, the <a href="https://hub.docker.com/_/postgres/">Postgres Official Image</a>
uses the following script as its <code class="highlighter-rouge">ENTRYPOINT</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">set</span> <span class="nt">-e</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">=</span> <span class="s1">'postgres'</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span>chown <span class="nt">-R</span> postgres <span class="s2">"</span><span class="nv">$PGDATA</span><span class="s2">"</span>

    <span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="k">$(</span><span class="nb">ls</span> <span class="nt">-A</span> <span class="s2">"</span><span class="nv">$PGDATA</span><span class="s2">"</span><span class="k">)</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span>gosu postgres initdb
    <span class="k">fi

    </span><span class="nb">exec </span>gosu postgres <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
<span class="k">fi

</span><span class="nb">exec</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
</code></pre></div></div>

<blockquote>
  <p>Configure app as PID 1</p>

  <p>This script uses <a href="http://wiki.bash-hackers.org/commands/builtin/exec">the <code class="highlighter-rouge">exec</code> Bash command</a>
so that the final running application becomes the container’s PID 1. This
allows the application to receive any Unix signals sent to the container.
For more, see the <a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#entrypoint"><code class="highlighter-rouge">ENTRYPOINT</code> reference</a>.</p>
</blockquote>

<p>ヘルパースクリプトはコンテナーの中にコピーされ、コンテナー開始時に <code class="highlighter-rouge">ENTRYPOINT</code> から実行されます。</p>

<pre><code class="language-Dockerfile">COPY ./docker-entrypoint.sh /
ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["postgres"]
</code></pre>

<p>このスクリプトを用いると、Postgres との間で、ユーザーがいろいろな方法でやり取りできるようになります。</p>

<p>以下は単純に Postgres を起動します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run postgres
</code></pre></div></div>

<p>あるいは PostgreSQL 実行時にサーバーに対してパラメーターを渡せます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run postgres postgres <span class="nt">--help</span>
</code></pre></div></div>

<p>または Bash のような全く異なるツールを起動するために利用することもできます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> postgres bash
</code></pre></div></div>

<h3 id="volume">VOLUME</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#volume">Dockerfile リファレンスの VOLUME コマンド</a></p>

<p><code class="highlighter-rouge">VOLUME</code> コマンドは、データベースストレージ領域、設定用ストレージ、Docker コンテナーによって作成されるファイルやフォルダの公開に使います。
イメージの可変的な部分、あるいはユーザーが設定可能な部分については VOLUME の利用が強く推奨されます。</p>

<h3 id="user">USER</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#user">Dockerfile リファレンスの USER コマンド</a></p>

<p>サービスが特権ユーザーでなくても実行できる場合は、<code class="highlighter-rouge">USER</code> を用いて非 root ユーザーに変更します。
ユーザーとグループを生成するところから始めてください。
<code class="highlighter-rouge">Dockerfile</code> 内にてたとえば <code class="highlighter-rouge">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> のようなコマンドを実行します。</p>

<blockquote>
  <p>明示的な UID、GID 指定</p>

  <p>イメージ内のユーザとグループに割り当てられる UID、GID は確定的なものではありません。
イメージが再構築されるかどうかには関係なく、「次の」値が UID、GID に割り当てられます。
これが問題となる場合は、UID、GID を明示的に割り当ててください。</p>
</blockquote>

<blockquote>
  <p>Go 言語の archive/tar パッケージが取り扱うスパースファイルにおいて
<a href="https://github.com/golang/go/issues/13548">未解決のバグ</a>があります。
これは Docker コンテナー内にて非常に大きな値の UID を使ってユーザーを生成しようとするため、ディスク消費が異常に発生します。
コンテナーレイヤ内の <code class="highlighter-rouge">/var/log/faillog</code> が NUL (\0) キャラクターにより埋められてしまいます。
useradd に対して <code class="highlighter-rouge">--no-log-init</code> フラグをつけることで、とりあえずこの問題は回避できます。
ただし Debian/Ubuntu の <code class="highlighter-rouge">adduser</code> ラッパーは <code class="highlighter-rouge">--no-log-init</code> フラグをサポートしていないため、利用することはできません。</p>
</blockquote>

<p>Avoid installing or using <code class="highlighter-rouge">sudo</code> as it has unpredictable TTY and
signal-forwarding behavior that can cause problems. If you absolutely need
functionality similar to <code class="highlighter-rouge">sudo</code>, such as initializing the daemon as <code class="highlighter-rouge">root</code> but
running it as non-<code class="highlighter-rouge">root</code>), consider using <a href="https://github.com/tianon/gosu">“gosu”</a>.</p>

<p>Lastly, to reduce layers and complexity, avoid switching <code class="highlighter-rouge">USER</code> back and forth
frequently.</p>

<h3 id="workdir">WORKDIR</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#workdir">Dockerfile リファレンスの WORKDIR コマンド</a></p>

<p><code class="highlighter-rouge">WORKDIR</code> に設定するパスは、分かり易く確実なものとするために、絶対パス指定としてください。
また <code class="highlighter-rouge">RUN cd … &amp;&amp; do-something</code> といった長くなる一方のコマンドを書くくらいなら、<code class="highlighter-rouge">WORKDIR</code> を利用してください。
そのような書き方は読みにくく、トラブル発生時には解決しにくく保守が困難になるためです。</p>

<h3 id="onbuild">ONBUILD</h3>

<p><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md#onbuild">Dockerfile リファレンスの ONBUILD コマンド</a></p>

<p><code class="highlighter-rouge">ONBUILD</code> コマンドは、<code class="highlighter-rouge">Dockerfile</code> によるビルドが完了した後に実行されます。
<code class="highlighter-rouge">ONBUILD</code> は、現在のイメージから <code class="highlighter-rouge">FROM</code> によって派生した子イメージにおいて実行されます。
つまり <code class="highlighter-rouge">ONBUILD</code> とは、親の <code class="highlighter-rouge">Dockerfile</code> から子どもの <code class="highlighter-rouge">Dockerfile</code> へ与える命令であると言えます。</p>

<p>Docker によるビルドにおいては <code class="highlighter-rouge">ONBUILD</code> の実行が済んでから、子イメージのコマンド実行が行われます。</p>

<p><code class="highlighter-rouge">ONBUILD</code> は、所定のイメージから <code class="highlighter-rouge">FROM</code> を使ってイメージをビルドしようとするときに利用できます。
たとえば特定言語のスタックイメージは <code class="highlighter-rouge">ONBUILD</code> を利用します。
<code class="highlighter-rouge">Dockerfile</code> 内にて、その言語で書かれたどのようなユーザーソフトウェアであってもビルドすることができます。
その例として <a href="https://github.com/docker-library/ruby/blob/master/2.1/onbuild/Dockerfile">Ruby’s ONBUILD variants</a> があります。</p>

<p><code class="highlighter-rouge">ONBUILD</code> によって構築するイメージは、異なったタグを指定してください。
たとえば <code class="highlighter-rouge">ruby:1.9-onbuild</code> と <code class="highlighter-rouge">ruby:2.0-onbuild</code> などです。</p>

<p><code class="highlighter-rouge">ONBUILD</code> において <code class="highlighter-rouge">ADD</code> や <code class="highlighter-rouge">COPY</code> を用いるときは注意してください。
“onbuild” イメージが新たにビルドされる際に、追加しようとしているリソースが見つからなかったとしたら、このイメージは復旧できない状態になります。上に示したように個別にタグをつけておけば、<code class="highlighter-rouge">Dockerfile</code> の開発者にとっても判断ができるようになるので、不測の事態は軽減されます。</p>

<h2 id="公式イメージの例">公式イメージの例</h2>

<p>以下に示すのは代表的な <code class="highlighter-rouge">Dockerfile</code> の例です。</p>

<ul>
  <li><a href="https://hub.docker.com/_/golang/">Go</a></li>
  <li><a href="https://hub.docker.com/_/perl/">Perl</a></li>
  <li><a href="https://hub.docker.com/_/hylang/">Hy</a></li>
  <li><a href="https://hub.docker.com/_/ruby/">Ruby</a></li>
</ul>

<h2 id="その他の情報">その他の情報</h2>

<ul>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/engine/reference/builder.md">Dockerfile リファレンス</a></li>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/baseimages/">ベースイメージの詳細</a></li>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/docker-hub/builds/">自動ビルドの詳細</a></li>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/docker-hub/official_images/">公式イメージ作成のガイドライン</a></li>
</ul>


							<!-- tags -->
							
							
							
							<span class="glyphicon glyphicon-tags" style="padding-right: 10px"></span><span style="vertical-align: 2px"><a href="https://matsuand.github.io/docs.docker.jp.onthefly/glossary/?term=parent image">parent image</a>, <a href="https://matsuand.github.io/docs.docker.jp.onthefly/glossary/?term=images">images</a>, <a href="https://matsuand.github.io/docs.docker.jp.onthefly/glossary/?term=dockerfile">dockerfile</a>, <a href="https://matsuand.github.io/docs.docker.jp.onthefly/glossary/?term=best practices">best practices</a>, <a href="https://matsuand.github.io/docs.docker.jp.onthefly/glossary/?term=hub">hub</a>, <a href="https://matsuand.github.io/docs.docker.jp.onthefly/glossary/?term=official image">official image</a></span>
							
							<!-- link corrections -->
              <script language="JavaScript">
							var x = document.links.length;
							var baseHref = document.getElementsByTagName('base')[0].href
							for (i = 0; i < x; i++) {
							  var munged = false;
							  var thisHREF = document.links[i].href;
							  var originalURL = "/develop/develop-images/dockerfile_best-practices/";
							  if (thisHREF.indexOf(baseHref + "#") > -1) {
							    // hash fix
							    //console.log('BEFORE: base:',baseHref,'thisHREF:',thisHREF,'originalURL:',originalURL);
							    thisHREF = originalURL + thisHREF.replace(baseHref, "");
							    //console.log('AFTER: base:',baseHref,'thisHREF:',thisHREF,'originalURL:',originalURL);
							  }
							  if ((thisHREF.indexOf(window.location.hostname) > -1 || thisHREF.indexOf('http') == -1) && document.links[i].className.indexOf("nomunge") < 0) {
							    munged = true;
							    thisHREF = thisHREF.replace(".md", "/").replace("/index/", "/");
							    document.links[i].setAttribute('href', thisHREF);
							  }
							}
							</script>
							
						  <div id="ratings-div" style="color:#b9c2cc; text-align: center; margin-top: 150px; visibility: hidden">
								<div id="pd_rating_holder_8453675"></div>
								<script type="text/javascript">
									PDRTJS_settings_8453675 = {
										"id": "8453675",
										"unique_id": "develop/develop-images/dockerfile_best-practices.md",
										"title": "Dockerfile 記述のベストプラクティス",
										"permalink": "https://github.com/docker/docker.github.io/blob/master/develop/develop-images/dockerfile_best-practices.md"
									};
									(function(d, c, j) {
										if (!document.getElementById(j)) {
											var pd = d.createElement(c),
												s;
											pd.id = j;
											pd.src = ('https:' == document.location.protocol) ? 'https://polldaddy.com/js/rating/rating.js' : 'http://i0.poll.fm/js/rating/rating.js';
											s = document.getElementsByTagName(c)[0];
											s.parentNode.insertBefore(pd, s);
										}
									}(document, 'script', 'pd-rating-js'));
								</script>
							</div>
							
						</section>
					</main>
					<nav class="col-nav">
						<div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
						<div id="navbar" class="nav-sidebar">
    <ul class="nav" id="jsTOCLeftNav">
    </ul>
</div>

						</div>
					</nav>
					<div class="col-toc">
							<div class="sidebar hidden-xs hidden-sm">
							<div class="toc-nav">
								<div class="feedback-links">
									<ul>
										
										<li style="visibility: hidden"><a href="https://github.com/matsuand/docs.docker.jp/edit/v18.09.local/develop/develop-images/dockerfile_best-practices.md"><i class="fa fa-pencil-square-o" aria-hidden="true"></i> このページの編集</a></li>
										<li><a href="https://github.com/matsuand/docs.docker.jp.onthefly/issues/new?body=File: [develop/develop-images/dockerfile_best-practices.md](https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/)"
															class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> 文書変更のリクエスト</a></li>
										<li><a href="https://success.docker.com/support"><i class="fa fa-question" aria-hidden="true"></i> サポート依頼</a></li>
										<!-- toggle mode -->
										<li>
											<div class="toggle-mode">
												<div class="icon">
													<i class="fa fa-sun-o" aria-hidden="true"></i>
												</div>
												<div class="toggle-switch">
													<label class="switch">
														<input type="checkbox" id="switch-style">
														<div class="slider round"></div>
												</label>
												</div>
												<div class="icon">
													<i class="fa fa-moon-o" aria-hidden="true"></i>
												</div>
											</div>
										</li>
									</ul>
								</div>
								   
									<div id="side-toc-title">本ページ内</div>
									
<ul id="my_toc" class="inline_toc">
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#一般的なガイドラインとアドバイス" class="nomunge">一般的なガイドラインとアドバイス</a>
    <ul>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#はかない-ephemeral-コンテナーの生成" class="nomunge">“はかない” (ephemeral) コンテナーの生成</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#ビルドコンテキストを理解する" class="nomunge">ビルドコンテキストを理解する</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#stdin-を通じた-dockerfile-のパイプ" class="nomunge">stdin を通じた Dockerfile のパイプ</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#exclude-with-dockerignore" class="nomunge">Exclude with .dockerignore</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#use-multi-stage-builds" class="nomunge">Use multi-stage builds</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#不要なパッケージをインストールしない" class="nomunge">不要なパッケージをインストールしない</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#アプリケーションの分割" class="nomunge">アプリケーションの分割</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#レイヤ数は最小に" class="nomunge">レイヤ数は最小に</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#複数行にわたる引数は並びを適切に" class="nomunge">複数行にわたる引数は並びを適切に</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#ビルドキャッシュの利用" class="nomunge">ビルドキャッシュの利用</a></li>
    </ul>
  </li>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#dockerfile-コマンド" class="nomunge">Dockerfile コマンド</a>
    <ul>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#from" class="nomunge">FROM</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#label" class="nomunge">LABEL</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#run" class="nomunge">RUN</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#cmd" class="nomunge">CMD</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#expose" class="nomunge">EXPOSE</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#env" class="nomunge">ENV</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#add-と-copy" class="nomunge">ADD と COPY</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#entrypoint" class="nomunge">ENTRYPOINT</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#volume" class="nomunge">VOLUME</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#user" class="nomunge">USER</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#workdir" class="nomunge">WORKDIR</a></li>
      <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#onbuild" class="nomunge">ONBUILD</a></li>
    </ul>
  </li>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#公式イメージの例" class="nomunge">公式イメージの例</a></li>
  <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/develop/develop-images/dockerfile_best-practices/#その他の情報" class="nomunge">その他の情報</a></li>
</ul>


								</div>
								
						</div>
					</div>
				</div>
			</div>
		</div>
	</div>

	
	<footer class="footer">
		  
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><a href="https://www.docker.com/what-docker">What is Docker</a></li>
                        <li><a href="https://www.docker.com/what-container">What is a Container</a></li>
                        <li><a href="https://www.docker.com/use-cases">Use Cases</a></li>
                        <li><a href="https://www.docker.com/customers">Customers</a></li>
                        <li><a href="https://www.docker.com/partners/partner-program">Partners</a></li>
                        <li class="break"><a href="https://www.docker.com/industry-government">For Government</a></li>
                        <li><a href="https://www.docker.com/company">About Docker</a></li>
                        <li><a href="https://www.docker.com/company/management">Management</a></li>
                        <li><a href="https://www.docker.com/company/news-and-press">Press &amp; News</a></li>
                        <li><a href="https://www.docker.com/careers">Careers</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><a href="https://www.docker.com/products/overview">Product</a></li>
                        <li><a href="https://www.docker.com/pricing">Pricing</a></li>
                        <li><a href="https://www.docker.com/docker-community">Community Edition</a></li>
                        <li class="break"><a href="https://www.docker.com/enterprise">Enterprise Edition </a></li>
                        <li><a href="https://www.docker.com/products/docker-datacenter">Docker Datacenter</a></li>
                        <li><a href="https://hub.docker.com/">Docker Hub</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><a href="https://matsuand.github.io/docs.docker.jp.onthefly/">Documentation</a></li>
                        <li><a href="https://www.docker.com/docker">Learn</a></li>
                        <li><a href="https://blog.docker.com" target="_blank">Blog</a></li>
                        <li><a href="https://engineering.docker.com" target="_blank">Engineering Blog</a></li>
                        <li><a href="https://training.docker.com/" target="_blank">Training</a></li>
                        <li><a href="https://success.docker.com/support">Support</a></li>
                        <li><a href="https://success.docker.com/kbase">Knowledge Base</a></li>
                        <li><a href="https://www.docker.com/products/resources">Resources</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><a href="https://www.docker.com/docker-community">Community</a></li>
                        <li><a href="https://www.docker.com/technologies/overview">Open Source</a></li>
                        <li><a href="https://www.docker.com/community/events">Events</a></li>
                        <li><a href="https://forums.docker.com/" target="_blank">Forums</a></li>
                        <li><a href="https://www.docker.com/community/docker-captains">Docker Captains</a></li>
                        <li><a href="https://www.docker.com/docker-community/scholarships">Scholarships</a></li>
                        <li><a href="https://blog.docker.com/curated/">Community News</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="http://status.docker.com/">Status</a></li>
                        <li><a href="https://www.docker.com/docker-security">Security</a></li>
                        <li><a href="https://www.docker.com/legal">Legal</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2019 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="http://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="http://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-reddit"><a href="http://www.reddit.com/r/docker">Reddit</a></li>
                    <li class="fa fa-slideshare"><a href="http://www.slideshare.net/docker">Slideshare</a></li>
                </ul>
            </div>
        </div>
    </div>

	</footer>
	<link rel="stylesheet" href="https://matsuand.github.io/docs.docker.jp.onthefly/css/github.css">
	
	<!-- <script src="https://matsuand.github.io/docs.docker.jp.onthefly/js/anchorlinks.js"></script> -->
	<script defer src="https://matsuand.github.io/docs.docker.jp.onthefly/js/menu.js"></script>
	<script src="https://matsuand.github.io/docs.docker.jp.onthefly/js/jquery.js"></script>
	<script src="https://matsuand.github.io/docs.docker.jp.onthefly/js/bootstrap.min.js"></script>
	<!-- Always include the archive.js, but it doesn't do much unless we are an archive -->
	<script language="javascript">
	// Default to assuming this is an archive and hiding some stuff
	// See js/archive.js and js/docs.js for logic relating to this
	var isArchive = true;
	var dockerVersion = 'v18.09';
	// In archives, we need to know the page root and we get it from JEKYLL_ENV in the jekyll build command
	var jekyllEnv = 'development';
	// If unset (in non-archive branches), defaults to "development". In that case, reset it to empty
	if (jekyllEnv == 'development') {
		jekyllEnv = '';
	}
	var pageURL = jekyllEnv + '/develop/develop-images/dockerfile_best-practices/';
	</script>
	<script src="https://matsuand.github.io/docs.docker.jp.onthefly/js/archive.js"></script>
	<script src="https://matsuand.github.io/docs.docker.jp.onthefly/js/stickyfill.min.js"></script>
	<script defer src="https://matsuand.github.io/docs.docker.jp.onthefly/js/metadata.js"></script>
	<script src="https://matsuand.github.io/docs.docker.jp.onthefly/js/glossary.js"></script>
	<script src="https://matsuand.github.io/docs.docker.jp.onthefly/js/collections_tocs.js"></script>
	<script defer src="https://matsuand.github.io/docs.docker.jp.onthefly/js/docs.js"></script>
	<script defer src="https://matsuand.github.io/docs.docker.jp.onthefly/js/toc.js"></script>
	<script language="javascript">
	jQuery(document).ready(function(){
				hookupTOCEvents();
			});
	</script>
</body>

</html>
