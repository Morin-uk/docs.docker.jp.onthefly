<!-- Page generated 2020-07-10 22:40:09 +0900 -->
<!-- Logic for 'edit this button'


    

    

    

    

    

    

    

    

-->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <style type="text/css">
      @charset "UTF-8";
      [ng\:cloak],
      [ng-cloak],
      [data-ng-cloak],
      [x-ng-cloak],
      .ng-cloak,
      .x-ng-cloak,
      .ng-hide:not(.ng-hide-animate) {
          display: none !important;
      }

      ng\:form {
          display: block;
      }
  </style>
  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WL2QLG5');</script>

  
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <meta name="msapplication-TileImage" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico">
  <link rel="apple-touch-icon" type="image/x-icon" href="/docs.docker.jp.onthefly/favicons/docs@2x.ico" sizes="129x128">
  <meta property="og:image" content="/docs.docker.jp.onthefly/favicons/docs@2x.ico"/>
  <!-- metadata -->
  <meta property="og:type" content="website"/>
  <meta property="og:updated_time" itemprop="dateUpdated" content="2020-07-10T22:40:09+09:00"/>
  <meta property="og:image" itemprop="image primaryImageOfPage" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:domain" content="docs.docker.com"/>
  <meta name="twitter:site" content="@docker_docs"/>
  <meta name="twitter:url" content="https://twitter.com/docker_docs"/>
  <meta name="twitter:title" itemprop="title name" content="ランタイムメトリックス"/>
  <meta name="twitter:description" property="og:description" itemprop="description" content="docker stats docker stats コマンドを使って、コンテナーの実行メトリックスからの出力を得ることができます。 このコマンドは、CPU、メモリ使用量、メモリ上限、ネットワーク I/O に対するメトリックスをサポートしています。 以下は docker stats コマンドの出力例です。 $ docker stats redis1 redis2 CONTAINER CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O..." />
  <meta name="twitter:image:src" content="/docs.docker.jp.onthefly/images/docs@2x.png"/>
  <meta name="twitter:image:alt" content="Docker ドキュメント"/>
  <meta property="article:published_time" itemprop="datePublished" content="2020-07-10T22:40:09+09:00"/>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="keywords" content="docker, metrics, CPU, memory, disk, IO, run, runtime, stats">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/font-awesome.min.css">
  <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/bootstrap.min.css">
  <link id="pygments" rel="stylesheet" href="/docs.docker.jp.onthefly/css/pygments/perldoc.css">
  <link id="pagestyle" rel="stylesheet" href="/docs.docker.jp.onthefly/css/style.css">

  <!-- Go get "Open Sans" font from Google -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  <!-- SEO stuff -->
  <title>ランタイムメトリックス | Docker ドキュメント</title>
  <meta property="og:title" content="ランタイムメトリックス" />
  <meta property="og:locale" content="ja_JP" />
  <meta name="description" content="Measure the behavior of running containers" />
  <meta property="og:description" content="Measure the behavior of running containers" />
  <link rel="canonical" href="/config/containers/runmetrics/" />
  <meta property="og:url" content="https://docs.docker.com/config/containers/runmetrics/" />
  <meta property="og:site_name" content="Docker ドキュメント" />
  <script type="application/ld+json">{"@context":"http://schema.org","@type":"WebPage","headline":"ランタイムメトリックス","description":"Measure the behavior of running containers","url":"https://docs.docker.com/config/containers/runmetrics/"}</script>
  <!-- END SEO STUFF -->
  
</head>


    <body ng-app="Docker" ng-controller="DockerController" class="colums">
    <header>
        <nav class="nav-secondary navbar navbar-fixed-top">
    <!-- <div class="fan"></div> -->
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="/docs.docker.jp.onthefly/">
                <img class="logo" src="/docs.docker.jp.onthefly/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs">
            </a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="logo-mobile">
    <a href="/docs.docker.jp.onthefly/">
        <img src="/docs.docker.jp.onthefly/images/docker-icon.svg" alt="Docker Docs" title="Docker Docs">
    </a>
</div>
<div class="search-form" id="search-div">
    <form class="search-form form-inline ng-pristine ng-valid" id="searchForm" action="/docs.docker.jp.onthefly/search/">
        <input class="search-field form-control ds-input" id="st-search-input" value="" name="q" placeholder="文書内検索" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteContainer">
            <div id="autocompleteResults"></div>
        </div>
        <!-- <button type="submit" class="search-submit btn btn-default">検索</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container hidden-sm hidden-xs">
    <div id="tabs">
        <ul class="tabs jsTOCHorizontal">

        </ul>
    </div>
    <div class="ctrl-right">
        <a href="javascript:void(0)" id="menu-toggle"><i class="fa fa-indent" aria-hidden="true"></i></a>
    </div>
</div>

        </div>
    </div>
</nav>

    </header>
    <div class="wrapper right-open">
        <div class="container-fluid">
            <div class="row">
                <div class="col-body">
                    <main class="col-content content">
                        <section class="section">
                            
                            
                            <h1>ランタイムメトリックス</h1> 
                            <span class="reading-time" title="Estimated reading time">
  <span class="reading-time-label">読む時間の目安: </span>
  
  
    9 分
  
</span>

                            
                            
<h2 id="docker-stats">docker stats</h2>

<p><code class="highlighter-rouge">docker stats</code> コマンドを使って、コンテナーの実行メトリックスからの出力を得ることができます。
このコマンドは、CPU、メモリ使用量、メモリ上限、ネットワーク I/O に対するメトリックスをサポートしています。</p>

<p>以下は <code class="highlighter-rouge">docker stats</code> コマンドの出力例です。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker stats redis1 redis2

CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O
redis1              0.07%               796 KB / 64 MB        1.21%               788 B / 648 B       3.568 MB / 512 KB
redis2              0.07%               2.746 MB / 64 MB      4.29%               1.266 KB / 648 B    12.4 MB / 0 B
</code></pre></div></div>

<p><a href="/docs.docker.jp.onthefly/engine/reference/commandline/stats/">docker stats</a> のリファレンスページでは、より詳細に <code class="highlighter-rouge">docker stats</code> コマンドについて説明しています。</p>

<h2 id="control-groups">コントロールグループ</h2>

<p>Linux のコンテナーは <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">コントロールグループ</a> に依存しています。
これは単に複数のプロセスを追跡するだけでなく、CPU、メモリ、ブロック I/O 使用量に関するメトリックスを提供します。
このメトリックスがアクセス可能であり、同様にネットワーク使用量メトリックスも得ることができます。
これは「純粋な」LXC コンテナーに関連があり、Docker のコンテナーにも関係します。</p>

<p>コントロールグループは擬似ファイルシステムを通じて提供されます。
最近のディストリビューションでは、このファイルシステムは <code class="highlighter-rouge">/sys/fs/cgroup</code> にあります。
このディレクトリの下には devices、freezer、blkio などのサブディレクトリが複数あります。
各サブディレクトリは、実にさまざまな cgroup 階層に対応しています。</p>

<p>かつてのシステムでは、コントロールグループが <code class="highlighter-rouge">/cgroup</code> にマウントされていて、わかりやすい階層構造にはなっていませんでした。
その場合サブディレクトリを確認していくのではなく、そのディレクトリ内の数多くのファイルを見てまわって、どこかにあるディレクトリが既存のコンテナーに対応するものであろう、と確認していくしかありませんでした。</p>

<p>コントロールグループがどこにマウントされているかを確認するには、以下を実行します。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep </span>cgroup /proc/mounts
</code></pre></div></div>

<h3 id="enumerate-cgroups">cgroups の確認</h3>

<p><code class="highlighter-rouge">/proc/cgroups</code> を覗いてみるとわかりますが、システムが利用するコントロールグループのサブシステムには実にさまざまなものがあり、それが階層化されていて、数多くのグループが属しているのがわかります。</p>

<p>また <code class="highlighter-rouge">/proc/&lt;pid&gt;/cgroup</code> を確認してみると、1 つのプロセスがどのコントロールグループに属しているかがわかります。
そのときのコントロールグループは、階層構造のルートとなるマウントポイントからの相対パスで表わされます。
<code class="highlighter-rouge">/</code> が表示されていれば、そのプロセスにはグループが割り当てられていません。
一方 <code class="highlighter-rouge">/lxc/pumpkin</code> といった表示になっていれば、そのプロセスは <code class="highlighter-rouge">pumpkin</code> という名のコンテナーのメンバーであることがわかります。</p>

<h3 id="find-the-cgroup-for-a-given-container">特定コンテナーに対応する cgroup の検索</h3>

<p>各コンテナーでは、各階層内に 1 つの cgroup が生成されます。
かつてのシステムにおいて、ユーザーランドツール LXC の古い版を利用している場合、cgroup 名はそのままコンテナー名になっています。
より新しい LXC ツールでの cgroup は <code class="highlighter-rouge">lxc/&lt;コンテナー名&gt;</code> となります。</p>

<p>cgroup を利用する Docker コンテナーにおいて、コンテナー名は、コンテナーの完全 ID か、あるいは長めの ID となります。
<code class="highlighter-rouge">docker ps</code> によってコンテナーが ae836c95b4c3 のように示されていたら、長めの ID はたとえば <code class="highlighter-rouge">ae836c95b4c3c9e9179e0e91015512da89fdec91612f63cebae57df9a5444c79</code> のようなものになります。
これは <code class="highlighter-rouge">docker inspect</code> を用いるか、あるいは <code class="highlighter-rouge">docker ps --no-trunc</code> とすれば確認することができます。</p>

<p>Docker コンテナーに対するメモリーメトリックスを取りまとめて確認するには、<code class="highlighter-rouge">/sys/fs/cgroup/memory/docker/&lt;longid&gt;/</code> を見ます。</p>

<h3 id="metrics-from-cgroups-memory-cpu-block-io">cgroups の各メトリックス、メモリ、CPU、ブロック I/O</h3>

<p>各サブシステム（メモリ、CPU、ブロック I/O）に対しては、擬似ファイルシステムが存在し、そこに統計情報が含まれます。</p>

<h4 id="memory-metrics-memorystat">メモリメトリックス: <code class="highlighter-rouge">memory.stat</code></h4>

<p>メモリメトリックスは cgroup の “memory” にあります。
メモリコントロールグループには多少のオーバーヘッドがあります。
ホスト上のメモリ利用量をきめ細かく算出しているためです。
したがって各種ディストリビューションの多くでは、デフォルトでこれを無効にしています。
これを有効にする方法は、一般的にはカーネルのコマンドラインパラメーター <code class="highlighter-rouge">cgroup_enable=memory swapaccount=1</code> といったものを追加するだけです。</p>

<p>メトリックスは擬似ファイルシステム <code class="highlighter-rouge">memory.stat</code> 内にあります。
これは以下のように表わされます。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cache 11492564992
rss 1930993664
mapped_file 306728960
pgpgin 406632648
pgpgout 403355412
swap 0
pgfault 728281223
pgmajfault 1724
inactive_anon 46608384
active_anon 1884520448
inactive_file 7003344896
active_file 4489052160
unevictable 32768
hierarchical_memory_limit 9223372036854775807
hierarchical_memsw_limit 9223372036854775807
total_cache 11492564992
total_rss 1930993664
total_mapped_file 306728960
total_pgpgin 406632648
total_pgpgout 403355412
total_swap 0
total_pgfault 728281223
total_pgmajfault 1724
total_inactive_anon 46608384
total_active_anon 1884520448
total_inactive_file 7003344896
total_active_file 4489052160
total_unevictable 32768
</code></pre></div></div>

<p>前半部分（<code class="highlighter-rouge">total_</code> が先頭につくものを除く）は cgroup 内のプロセスに対応する統計情報であり、サブ crgoup は除くものです。
後半部分（<code class="highlighter-rouge">total_</code> が先頭につくもの）は同様ですが、ただしサブ cgroup を含むものです。</p>

<p>メトリックスの中には「メーター」、つまり増減を繰り返す値表記になっているものがあります。
たとえば <code class="highlighter-rouge">swap</code> は、cgroup のメンバーによって利用されるスワップ容量の合計です。
この他に「カウンター」となっているもの、つまり数値がカウントアップされていくものがあります。
これは特定のイベントがどれだけ発生したかを表わしています。
たとえば <code class="highlighter-rouge">pgfault</code> は cgroup の生成以降に、どれだけページフォールトが発生したかを表わします。</p>

<style>table tr > td:first-child { white-space: nowrap;}</style>

<table>
  <thead>
    <tr>
      <th>メトリックス</th>
      <th>内容説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>cache</strong></td>
      <td>このコントロールグループのプロセスが利用するメモリ使用量。ブロックデバイス上の各ブロックに細かく関連づけられるものです。ディスク上のファイルと読み書きを行うと、この値が増加します。ふだん利用する I/O（システムコールの <code class="highlighter-rouge">open</code>、<code class="highlighter-rouge">read</code>、<code class="highlighter-rouge">write</code>）利用時に発生し、（<code class="highlighter-rouge">mmap</code> を用いた）マップファイルの場合も同様です。<code class="highlighter-rouge">tmpfs</code> が利用するメモリをこれにより説明されますが、理由は明らかではありません。</td>
    </tr>
    <tr>
      <td><strong>rss</strong></td>
      <td>ディスク上の操作に対応づかないメモリ使用量。たとえばスタック、ヒープ、匿名メモリマップなどです。</td>
    </tr>
    <tr>
      <td><strong>mapped_file</strong></td>
      <td>このコントロールグループのプロセスによってマッピングされるメモリの使用量。メモリを <strong>どれだけ</strong> 利用しているかの情報は得られません。ここからわかるのは <strong>どのように</strong> 利用されているかです。</td>
    </tr>
    <tr>
      <td><strong>pgfault</strong>, <strong>pgmajfault</strong></td>
      <td>cgroup のプロセスにおいて発生した「ページフォールト」、「メジャーフォールト」の回数を表わします。ページフォールトは、プロセスがアクセスした仮想メモリスペースの一部が、存在していないかアクセス拒否された場合に発生します。存在しないというのは、そのプロセスにバグがあり、不正なアドレスにアクセスしようとしたことを表わします（<code class="highlighter-rouge">SIGSEGV</code> シグナルが送信され、<code class="highlighter-rouge">Segmentation fault</code> といういつものメッセージを受けたとたんに、プロセスが停止されます）。アクセス拒否されるのは、スワップしたメモリ領域、あるいはマップファイルに対応するメモリ領域を読み込もうとしたときに発生します。この場合、カーネルがディスクからページを読み込み、CPU のメモリアクセスを成功させます。またコピーオンライトメモリ領域へプロセスが書き込みを行う場合にも発生することがあります。同様にカーネルがプロセスの切り替え（preemption）を行ってからメモリページを複製し、ページ内のプロセス自体のコピーに対して書き込み処理を復元します。「メジャーフォールト」はカーネルがディスクからデータを読み込む必要がある際に発生します。既存ページを複製する場合や空のページを割り当てる場合は、通常の（つまり「マイナー」の）フォールトになります。</td>
    </tr>
    <tr>
      <td><strong>swap</strong></td>
      <td>この cgroup 内のプロセスによって現時点利用されているスワップ総量。</td>
    </tr>
    <tr>
      <td><strong>active_anon</strong>、<strong>inactive_anon</strong></td>
      <td>カーネルによって <strong>アクティブ</strong> か <strong>非アクティブ</strong> のいずれかに特定される <strong>匿名</strong> メモリの使用量。”匿名” メモリとは、ディスクページにひもづいて <strong>いない</strong> メモリのことです。別の表現でいえば、上で示した rss カウンターと同等のものです。正確な rss カウンターの定義式は、<strong>active_anon</strong> ＋ <strong>inactive_anon</strong> － <strong>tmpfs</strong> です。（コントロールグループが <code class="highlighter-rouge">tmpfs</code> ファイルシステムをマウントしている場合に、ここでいう tmpfs は、そのファイルシステムが利用するメモリ使用量のことです。）では “アクティブ” と “非アクティブ” の違いは？  ページは初めは “アクティブ” です。一定間隔でカーネルがメモリを走査し、一部に “非アクティブ” というタグをつけます。再度アクセスが行われると、すぐに “アクティブ” というタグにつけかえられます。カーネルがほぼメモリ不足に陥って、ディスクへのスワップが必要になると、カーネルは “非アクティブ” ページをスワップします。</td>
    </tr>
    <tr>
      <td><strong>active_file</strong>, <strong>inactive_file</strong></td>
      <td>上で示した <strong>anon</strong> メモリと同様、<strong>アクティブ</strong>、<strong>非アクティブ</strong> の状態があるキャッシュメモリのこと。正確な式で表現すると、<strong>cache</strong> ＝ <strong>active_file</strong> ＋ <strong>inactive_file</strong> ＋ <strong>tmpfs</strong> です。カーネルが採用する規則として、アクティブ、非アクティブなメモリページを移動させる方法は、匿名メモリのときとは異なります。ただしその一般的な原理は同じです。カーネルがメモリを要求するとき、クリーンな（修正がかかっていない）ページを取り出すことの方が、簡単に済みます。取り出すことがすぐにできるからです。（一方、匿名ページや、汚れた修正のかかったページでは、その前にディスクに書き出すことが必要になるからです。）</td>
    </tr>
    <tr>
      <td><strong>unevictable</strong></td>
      <td>取り出し要求ができないメモリ量のこと。一般には <code class="highlighter-rouge">mlock</code> によって “ロックされた” メモリとされます。暗号フレームワークにおいて利用されることがあり、その場合、秘密鍵や機密情報がディスクにスワップされないようにするものです。</td>
    </tr>
    <tr>
      <td><strong>memory_limit</strong>, <strong>memsw_limit</strong></td>
      <td>これは実際のメトリックスではありません。この cgroup に適用される上限を確認するためのものです。<strong>memory_limit</strong> は、このコントロールグループのプロセスが利用可能な物理メモリの最大容量を示します。<strong>memsw_limit</strong> は RAM ＋ スワップの最大容量を示します。</td>
    </tr>
  </tbody>
</table>

<p>ページキャッシュ内のメモリの計算は非常に複雑です。
コントロールグループの異なるプロセスが 2 つあって、それが同一のファイル（最終的にディスク上の同一ブロックに存在）を読み込むとします。
その際のメモリチャージは、それぞれのコントロールグループに分割されます。
これは一見すると良いことのように見えます。
しかし一方の cgroup が停止したとします。
そうすると他方の cgroup におけるメモリ使用量が増大してしまうことになります。
両者のメモリページに対する使用コストは、もう共有されていないからです。</p>

<h3 id="cpu-metrics-cpuacctstat">CPU メトリックス: <code class="highlighter-rouge">cpuacct.stat</code></h3>

<p>これまでメモリメトリックスについて説明してきました。
これ以外のものは比較的簡単です。
CPU メトリックスは <code class="highlighter-rouge">cpuacct</code> コントローラー内にあります。</p>

<p>各コンテナーに対応して擬似ファイル <code class="highlighter-rouge">cpuacct.stat</code> があり、コンテナープロセスの CPU 使用時間が積算されています。
そしてこれが <code class="highlighter-rouge">user</code> 時間と <code class="highlighter-rouge">system</code> 時間に割り振られています。
両者の違いは以下のとおりです。</p>

<ul>
  <li><code class="highlighter-rouge">user</code> 時間は、プロセスが CPU を直接制御して、プロセスコードを実行している時間のことです。
executing process code.</li>
  <li><code class="highlighter-rouge">system</code> 時間は、カーネルがプロセスのためにシステムコールを実行している時間のことです。</li>
</ul>

<p>この時間は 1/100 秒の tick という周期で表わされます。
別名「user jiffies」ともいいます。
1 秒には <code class="highlighter-rouge">USER_HZ</code> 分の “<strong>jiffies</strong>” があり、x86 システムでは <code class="highlighter-rouge">USER_HZ</code> は 100 です。
これまでの経緯として、これは 1 秒に割り当てられるスケジューラー “ticks” の数です。
ただしそれ以上に頻繁にスケジューリングされることや、<a href="http://lwn.net/Articles/549580/">tickless kernels</a> があり、これらは ticks 数は関係がなくなります。</p>

<h4 id="block-io-metrics">ブロック I/O メトリックス</h4>

<p>ブロック I/O は <code class="highlighter-rouge">blkio</code> コントローラー内において計算されます。
さまざまなメトリックスが、さまざまなファイルにわたって保持されています。
より詳細は、カーネルドキュメント内にある <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt">blkio-controller</a> ファイルに記述されていますが、以下では最も関連のある内容を手短に示します。</p>

<table>
  <thead>
    <tr>
      <th>メトリックス</th>
      <th>内容説明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>blkio.sectors</strong></td>
      <td>512 バイトのセクター数。cgroup のプロセスメンバーによって、デバイスごとに読み書きされます。読み書きは 1 つのカウンターに合計されます。</td>
    </tr>
    <tr>
      <td><strong>blkio.io_service_bytes</strong></td>
      <td>cgroup によって読み書きされるバイト数を表わします。デバイスごとに 4 つのカウンターがあり、1 つのデバイスつき、同期、非同期 I/O の別、読み込み、書き込みの別が示されています。</td>
    </tr>
    <tr>
      <td><strong>blkio.io_serviced</strong></td>
      <td>処理された I/O 操作の数。そのサイズとは無関係です。デバイスごとに、やはり 4 つのカウンターがあります。</td>
    </tr>
    <tr>
      <td><strong>blkio.io_queued</strong></td>
      <td>この cgroup において、その時点でキューに入っている I/O 操作の数を表わします。言い換えると  cgroup に I/O が発生していなければ、この値はゼロになります。一方、この逆は正しくなりません。I/O がキューに入っていなかったとしても、それは cgroup が（I/O 的に）アイドルであるとは言えません。普段は静止しているデバイスが、純粋に同期読み込み処理を行っているかもしれないからです。その場合には、I/O 操作をすぐに処理できるわけであり、キューに入れることなく扱うことができます。またこのメトリックスは I/O サブシステム上のどの cgroup に負荷がかかっているかがわかります。ただし示される値は相対的な量にすぎません。プロセスグループがこれ以上に I/O を処理しない場合であっても、他のデバイスの影響によりデバイス負荷が増加するため、キューサイズも増加することになります。</td>
    </tr>
  </tbody>
</table>

<h3 id="network-metrics">ネットワークメトリックス</h3>

<p>ネットワークメトリックスは、コントロールグループによって直接表わされるものではありません。
わかりやすく説明します。
ネットワークインターフェースは、<strong>ネットワーク名前空間</strong> コンテキストの中に存在します。
カーネルは、プロセスグループとの間で送受信されるパケットやバイトに関して、メトリックスを収集します。
ただこのメトリックスはあまり役に立つものではありません。
欲しいのはインターフェースごとのメトリックスであるはずです。
（なぜならメトリックスでは <code class="highlighter-rouge">lo</code> インターフェースに発生するトラフィックはカウントされません。）
もっとも 1 つの cgroup は、複数のネットワーク名前空間に属することができるため、そのメトリックスを計算することは、より難しくなります。
複数のネットワーク名前空間になるということは、<code class="highlighter-rouge">lo</code> インターフェースが複数あるということであり、場合によっては複数の <code class="highlighter-rouge">eth0</code> インターフェースを持つこともあります。
コントロールグループを用いてネットワークメトリックスを簡単に集めることができないのは、こういった理由によります。</p>

<p>そのかわり、ネットワークメトリックスは別の情報から収集することができます。</p>

<h4 id="iptables">IPtables</h4>

<p>iptables （むしろ iptables がインターフェースとなる netfilter フレームワーク）から重要な情報が得られます。</p>

<p>たとえばウェブサーバー上におけるアウトバウンド HTTP トラフィックを計算するルールを設定することができます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>iptables <span class="nt">-I</span> OUTPUT <span class="nt">-p</span> tcp <span class="nt">--sport</span> 80
</code></pre></div></div>

<p>ここでは <code class="highlighter-rouge">-j</code> フラグや <code class="highlighter-rouge">-g</code> フラグは用いません。
このルールがパケットをカウントし、後続のルールの処理を行います。</p>

<p>このカウンター値は以下のようにして確認できます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>iptables <span class="nt">-nxvL</span> OUTPUT
</code></pre></div></div>

<p>Technically, <code class="highlighter-rouge">-n</code> is not required, but it
prevents iptables from doing DNS reverse lookups, which are probably
useless in this scenario.</p>

<p>Counters include packets and bytes. If you want to setup metrics for
container traffic like this, you could execute a <code class="highlighter-rouge">for</code>
loop to add two <code class="highlighter-rouge">iptables</code> rules per
container IP address (one in each direction), in the <code class="highlighter-rouge">FORWARD</code>
chain. This only meters traffic going through the NAT
layer; you also need to add traffic going through the userland
proxy.</p>

<p>Then, you need to check those counters on a regular basis. If you
happen to use <code class="highlighter-rouge">collectd</code>, there is a <a href="https://collectd.org/wiki/index.php/Table_of_Plugins">nice plugin</a>
to automate iptables counters collection.</p>

<h4 id="interface-level-counters">Interface-level counters</h4>

<p>Since each container has a virtual Ethernet interface, you might want to check
directly the TX and RX counters of this interface. Each container is associated
to a virtual Ethernet interface in your host, with a name like <code class="highlighter-rouge">vethKk8Zqi</code>.
Figuring out which interface corresponds to which container is, unfortunately,
difficult.</p>

<p>But for now, the best way is to check the metrics <em>from within the
containers</em>. To accomplish this, you can run an executable from the host
environment within the network namespace of a container using <strong>ip-netns
magic</strong>.</p>

<p>The <code class="highlighter-rouge">ip-netns exec</code> command allows you to execute any
program (present in the host system) within any network namespace
visible to the current process. This means that your host can
 enter the network namespace of your containers, but your containers
can’t access the host or other peer containers.
Containers can interact with their sub-containers, though.</p>

<p>The exact format of the command is:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ip netns <span class="nb">exec</span> &lt;nsname&gt; &lt;command...&gt;
</code></pre></div></div>

<p>For example:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ip netns <span class="nb">exec </span>mycontainer netstat <span class="nt">-i</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ip netns</code> finds the “mycontainer” container by
using namespaces pseudo-files. Each process belongs to one network
namespace, one PID namespace, one <code class="highlighter-rouge">mnt</code> namespace,
etc., and those namespaces are materialized under
<code class="highlighter-rouge">/proc/&lt;pid&gt;/ns/</code>. For example, the network
namespace of PID 42 is materialized by the pseudo-file
<code class="highlighter-rouge">/proc/42/ns/net</code>.</p>

<p>When you run <code class="highlighter-rouge">ip netns exec mycontainer ...</code>, it
expects <code class="highlighter-rouge">/var/run/netns/mycontainer</code> to be one of
those pseudo-files. (Symlinks are accepted.)</p>

<p>In other words, to execute a command within the network namespace of a
container, we need to:</p>

<ul>
  <li>Find out the PID of any process within the container that we want to investigate;</li>
  <li>Create a symlink from <code class="highlighter-rouge">/var/run/netns/&lt;somename&gt;</code> to <code class="highlighter-rouge">/proc/&lt;thepid&gt;/ns/net</code></li>
  <li>Execute <code class="highlighter-rouge">ip netns exec &lt;somename&gt; ....</code></li>
</ul>

<p>Review <a href="#enumerate-cgroups">Enumerate Cgroups</a> for how to find
the cgroup of an in-container process whose network usage you want to measure.
From there, you can examine the pseudo-file named
<code class="highlighter-rouge">tasks</code>, which contains all the PIDs in the
cgroup (and thus, in the container). Pick any one of the PIDs.</p>

<p>Putting everything together, if the “short ID” of a container is held in
the environment variable <code class="highlighter-rouge">$CID</code>, then you can do this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ TASKS</span><span class="o">=</span>/sys/fs/cgroup/devices/docker/<span class="nv">$CID</span><span class="k">*</span>/tasks
<span class="nv">$ PID</span><span class="o">=</span><span class="k">$(</span>head <span class="nt">-n</span> 1 <span class="nv">$TASKS</span><span class="k">)</span>
<span class="nv">$ </span>mkdir <span class="nt">-p</span> /var/run/netns
<span class="nv">$ </span>ln <span class="nt">-sf</span> /proc/<span class="nv">$PID</span>/ns/net /var/run/netns/<span class="nv">$CID</span>
<span class="nv">$ </span>ip netns <span class="nb">exec</span> <span class="nv">$CID</span> netstat <span class="nt">-i</span>
</code></pre></div></div>

<h2 id="tips-for-high-performance-metric-collection">Tips for high-performance metric collection</h2>

<p>Running a new process each time you want to update metrics is
(relatively) expensive. If you want to collect metrics at high
resolutions, and/or over a large number of containers (think 1000
containers on a single host), you do not want to fork a new process each
time.</p>

<p>Here is how to collect metrics from a single process. You need to
write your metric collector in C (or any language that lets you do
low-level system calls). You need to use a special system call,
<code class="highlighter-rouge">setns()</code>, which lets the current process enter any
arbitrary namespace. It requires, however, an open file descriptor to
the namespace pseudo-file (remember: that’s the pseudo-file in
<code class="highlighter-rouge">/proc/&lt;pid&gt;/ns/net</code>).</p>

<p>However, there is a catch: you must not keep this file descriptor open.
If you do, when the last process of the control group exits, the
namespace is not destroyed, and its network resources (like the
virtual interface of the container) stays around forever (or until
you close that file descriptor).</p>

<p>The right approach would be to keep track of the first PID of each
container, and re-open the namespace pseudo-file each time.</p>

<h2 id="collect-metrics-when-a-container-exits">Collect metrics when a container exits</h2>

<p>Sometimes, you do not care about real time metric collection, but when a
container exits, you want to know how much CPU, memory, etc. it has
used.</p>

<p>Docker makes this difficult because it relies on <code class="highlighter-rouge">lxc-start</code>, which carefully
cleans up after itself. It is usually easier to collect metrics at regular
intervals, and this is the way the <code class="highlighter-rouge">collectd</code> LXC plugin works.</p>

<p>But, if you’d still like to gather the stats when a container stops,
here is how:</p>

<p>For each container, start a collection process, and move it to the
control groups that you want to monitor by writing its PID to the tasks
file of the cgroup. The collection process should periodically re-read
the tasks file to check if it’s the last process of the control group.
(If you also want to collect network statistics as explained in the
previous section, you should also move the process to the appropriate
network namespace.)</p>

<p>When the container exits, <code class="highlighter-rouge">lxc-start</code> attempts to
delete the control groups. It fails, since the control group is
still in use; but that’s fine. Your process should now detect that it is
the only one remaining in the group. Now is the right time to collect
all the metrics you need!</p>

<p>Finally, your process should move itself back to the root control group,
and remove the container control group. To remove a control group, just
<code class="highlighter-rouge">rmdir</code> its directory. It’s counter-intuitive to
<code class="highlighter-rouge">rmdir</code> a directory as it still contains files; but
remember that this is a pseudo-filesystem, so usual rules don’t apply.
After the cleanup is done, the collection process can exit safely.</p>

                            <!-- tags -->
                            
                            <span class="glyphicon glyphicon-tags" style="padding-right: 10px"></span><span
                                style="vertical-align: 2px"><a
                                    href="https://docs.docker.com/search/?q=docker">docker</a>, <a
                                    href="https://docs.docker.com/search/?q=metrics">metrics</a>, <a
                                    href="https://docs.docker.com/search/?q=CPU">CPU</a>, <a
                                    href="https://docs.docker.com/search/?q=memory">memory</a>, <a
                                    href="https://docs.docker.com/search/?q=disk">disk</a>, <a
                                    href="https://docs.docker.com/search/?q=IO">IO</a>, <a
                                    href="https://docs.docker.com/search/?q=run">run</a>, <a
                                    href="https://docs.docker.com/search/?q=runtime">runtime</a>, <a
                                    href="https://docs.docker.com/search/?q=stats">stats</a></span>
                            
                            
                            <div id="ratings-div"
                                style="color:#b9c2cc; text-align: center; margin-top: 150px;">
                                <div id="pd_rating_holder_8453675"></div>
                                <script type="text/javascript">
                                    PDRTJS_settings_8453675 = {
                                        "id": "8453675",
                                        "unique_id": "config/containers/runmetrics.md",
                                        "title": "ランタイムメトリックス",
                                        "permalink": "https://github.com/docker/docker.github.io/blob/master/config/containers/runmetrics.md"
                                    };
                                    (function (d, c, j) {
                                        if (!document.getElementById(j)) {
                                            var pd = d.createElement(c),
                                                s;
                                            pd.id = j;
                                            pd.src = ('https:' == document.location.protocol) ? 'https://polldaddy.com/js/rating/rating.js' : 'http://i0.poll.fm/js/rating/rating.js';
                                            s = document.getElementsByTagName(c)[0];
                                            s.parentNode.insertBefore(pd, s);
                                        }
                                    }(document, 'script', 'pd-rating-js'));
                                </script>
                            </div>
                            
                        </section>
                    </main>
                    <nav class="col-nav">
                        <div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
                            <div id="navbar" class="nav-sidebar">
    <ul class="nav jsTOCHorizontal hidden-md hidden-lg">
    </ul>
    <div class="divider hidden-md hidden-lg"></div>
    <ul class="nav" id="jsTOCLeftNav">
    </ul>
</div>

                        </div>
                    </nav>
                    <div class="col-toc">
                        <div class="sidebar hidden-xs hidden-sm">
                            <div class="toc-nav">
                                <div class="feedback-links">
                                    <ul>
                                        
                                        <li><a href="https://github.com/matsuand/docs.docker.jp/edit/v19.03.local/config/containers/runmetrics.md"><i
                                                    class="fa fa-pencil-square-o" aria-hidden="true"></i> このページの編集</a></li>
                                        <li><a href="https://github.com/matsuand/docs.docker.jp/issues/new?body=ファイル: [config/containers/runmetrics.md](https://matsuand.github.io/docs.docker.jp.onthefly/config/containers/runmetrics/)"
                                                class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> 文書変更のリクエスト</a></li>
                                        <!-- toggle mode -->
                                        <li>
                                            <div class="toggle-mode">
                                                <div class="icon">
                                                    <i class="fa fa-sun-o" aria-hidden="true"></i>
                                                </div>
                                                <div class="toggle-switch">
                                                    <label class="switch">
                                                        <input type="checkbox" id="switch-style">
                                                        <div class="slider round"></div>
                                                    </label>
                                                </div>
                                                <div class="icon">
                                                    <i class="fa fa-moon-o" aria-hidden="true"></i>
                                                </div>
                                            </div>
                                        </li>
                                    </ul>
                                </div>
                                
                                
                                
                                
                                <div id="side-toc-title">本ページ内:</div>
                                
<ul id="my_toc" class="inline_toc">
  <li><a href="#docker-stats" class="nomunge">docker stats</a></li>
  <li><a href="#control-groups" class="nomunge">コントロールグループ</a>
    <ul>
      <li><a href="#enumerate-cgroups" class="nomunge">cgroups の確認</a></li>
      <li><a href="#find-the-cgroup-for-a-given-container" class="nomunge">特定コンテナーに対応する cgroup の検索</a></li>
      <li><a href="#metrics-from-cgroups-memory-cpu-block-io" class="nomunge">cgroups の各メトリックス、メモリ、CPU、ブロック I/O</a></li>
      <li><a href="#cpu-metrics-cpuacctstat" class="nomunge">CPU メトリックス: cpuacct.stat</a></li>
      <li><a href="#network-metrics" class="nomunge">ネットワークメトリックス</a></li>
    </ul>
  </li>
  <li><a href="#tips-for-high-performance-metric-collection" class="nomunge">Tips for high-performance metric collection</a></li>
  <li><a href="#collect-metrics-when-a-container-exits" class="nomunge">Collect metrics when a container exits</a></li>
</ul>


                                
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
    <footer class="footer">
          
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/why-docker">Why Docker?</a></b></li>
                        <li><a href="https://www.docker.com/what-container">What is a Container?</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/overview">Products</a></b></li>
                        <li><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></li>
                        <li><a href="https://www.docker.com/products/docker-hub">Docker Hub</a></li>
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Features</a></b></li>
                        <li><a href="https://www.docker.com/products/container-runtime">Container Runtime</a></li>
                        <li><a href="https://www.docker.com/products/developer-tools">Developer Tools</a></li>
                        <li><a href="https://www.docker.com/products/kubernetes">Kubernetes</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Developers</a></b></li>
                        <li><a href="https://www.docker.com/use-cases">Use Cases</a></li>
                        <li><a href="https://www.docker.com/play-with-docker">Play with Docker</a></li>
                        <li><a href="https://www.docker.com/docker-community">Community</a></li>
                        <li><a href="https://www.docker.com/open-source">Open Source</a></li>
                        <li><a href="https://www.docker.com/community/docker-captains">Docker Captains</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/company" target="_blank">Company</a></b></li>
                        <li><a href="https://www.docker.com/company">About Us</a></li>
                        <li><a href="https://www.docker.com/blog/" target="_blank">Blog</a></li>
                        <li><a href="https://www.docker.com/customers">Customers</a></li>
                        <li><a href="https://www.docker.com/partners">Partners</a></li>
                        <li><a href="https://www.docker.com/company/newsroom">Newsroom</a></li>
                        <li><a href="https://www.docker.com/careers">Careers</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact Us</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="http://status.docker.com/">Status</a></li>
                        <li><a href="https://www.docker.com/docker-security">Security</a></li>
                        <li><a href="https://www.docker.com/legal">Legal</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2013-2020 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="http://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="http://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-slideshare"><a href="https://www.slideshare.net/docker">Slideshare</a></li>
                    <li class="fa fa-reddit"><a href="https://www.reddit.com/r/docker">Reddit</a></li>
                </ul>
            </div>
        </div>
    </div>

    </footer>
    <link rel="stylesheet" href="/docs.docker.jp.onthefly/css/github.css">
    
    <script>var pageURL = "/config/containers/runmetrics/";</script>
    <script defer src="/docs.docker.jp.onthefly/js/anchorlinks.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/menu.js"></script>
    <script src="/docs.docker.jp.onthefly/js/jquery.js"></script>
    <script src="/docs.docker.jp.onthefly/js/bootstrap.min.js"></script>
    <script src="/docs.docker.jp.onthefly/js/stickyfill.min.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/metadata.js"></script>
    <script src="/docs.docker.jp.onthefly/js/glossary.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/docs.js"></script>
    <script defer src="/docs.docker.jp.onthefly/js/toc.js"></script>
    <script defer src="/js/search.js"></script>
</body>


</html>
