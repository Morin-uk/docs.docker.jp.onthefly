<ul class="pagination">
  <li><a href="/docs.docker.jp.onthefly/get-started/nodejs/build-images/">イメージのビルド</a></li>
  <li class="active"><a href="/docs.docker.jp.onthefly/get-started/nodejs/run-containers/">イメージのコンテナーとしての実行</a></li>
  <li><a href="/docs.docker.jp.onthefly/get-started/nodejs/develop/">開発向けのコンテナー利用</a></li>
</ul>

<h2 id="prerequisites">前提条件</h2>

<p><a href="/docs.docker.jp.onthefly/get-started/nodejs/build-images/">Node イメージのビルド</a> に示した Node JS のビルド手順を行っていること。</p>

<h2 id="overview">概要</h2>

<p>前のチュートリアルではサンプルアプリケーションを生成し、イメージ生成に利用する Dockerfile を生成しました。
そして<code class="language-plaintext highlighter-rouge">docker build</code>コマンドを実行してイメージを生成しました。
イメージができあがったので、このイメージを実行しアプリケーションが正しく動作することを確認します。</p>

<p>コンテナーとはオペレーティングシステムにおける普通の 1 プロセスです。
ただしそのプロセスは他から分離され、独自のファイルシステム、独自のネットワークを持ち、ホストからは分離したプロセスツリーを持ちます。</p>

<p>コンテナー内部においてイメージを実行するには<code class="language-plaintext highlighter-rouge">docker run</code>コマンドを使います。
<code class="language-plaintext highlighter-rouge">docker run</code>コマンドには 1 つのパラメーター、つまりイメージ名を指定します。
イメージを起動してこれが正しく動作することを確認します。
ターミナルから以下のコマンドを実行してください。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run node-docker
</code></pre></div></div>

<p>このコマンドを実行すると、コマンドプロンプトには戻ってこないことがわかります。
こうなる理由は、ここで用いるアプリケーションが REST サーバーであり、受信するリクエストを待つループ処理により実行されるからです。
コンテナーを停止させない限り、制御が OS に戻ることはありません。</p>

<p>サーバーに GET リクエストを送信する curl コマンドを実行します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">--request</span> POST <span class="se">\</span>
  <span class="nt">--url</span> http://localhost:8000/test <span class="se">\</span>
  <span class="nt">--header</span> <span class="s1">'content-type: application/json'</span> <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{
	"msg": "testing"
}'</span>
curl: <span class="o">(</span>7<span class="o">)</span> Failed to connect to localhost port 8000: Connection refused
</code></pre></div></div>

<p>curl コマンドが失敗する原因は、サーバーへの接続が拒否されたからです。
つまりローカルホストのポート 8000 に接続ができなかったことを意味します。
そうなることはわかっていたことです。
コンテナーは分離された状態で実行されていて、ネットワークに関しても同様だからです。
そこでコンテナーを停止させ、ローカルホスト上にポート 8000 を公開した上で再起動してみます。</p>

<p>コンテナーの停止には ctrl-c を入力します。
これによりターミナルプロンプトに戻ります。</p>

<p>コンテナーのポートを公開するには、docker run コマンドにおいて<code class="language-plaintext highlighter-rouge">--publish</code>フラグ（または短く<code class="language-plaintext highlighter-rouge">-p</code>）を指定します。
<code class="language-plaintext highlighter-rouge">--publish</code>の書式は<code class="language-plaintext highlighter-rouge">[ホストポート]:[コンテナーポート]</code>とします。
そこでコンテナー内部のポート 8000 を、コンテナーの外に対してポート 3000 により公開したい場合は、--publish フラグに 3000:8000 を指定します。</p>

<p>コンテナーを起動させ、ここではポート 8000 をホスト上のポート 8000 に公開します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">--publish</span> 8000:8000 node-docker
</code></pre></div></div>

<p>そこで先ほどと同じ curl コマンドを再実行してみます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">--request</span> POST <span class="se">\</span>
  <span class="nt">--url</span> http://localhost:8000/test <span class="se">\</span>
  <span class="nt">--header</span> <span class="s1">'content-type: application/json'</span> <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{
	"msg": "testing"
}'</span>
<span class="o">{</span><span class="s2">"code"</span>:<span class="s2">"success"</span>,<span class="s2">"payload"</span>:[<span class="o">{</span><span class="s2">"msg"</span>:<span class="s2">"testing"</span>,<span class="s2">"id"</span>:<span class="s2">"dc0e2c2b-793d-433c-8645-b3a553ea26de"</span>,<span class="s2">"createDate"</span>:<span class="s2">"2020-09-01T17:36:09.897Z"</span><span class="o">}]}</span>
</code></pre></div></div>

<p>成功しました。
コンテナー内部で実行されているアプリケーションに対して、ポート 8000 から接続できたということです。
コンテナーを実行しているターミナルに戻って、画面上に表示された POST リクエストのログを確認してください。</p>

<p><code class="language-plaintext highlighter-rouge">2020-09-01T17:36:09:8770  INFO: POST /test</code></p>

<p>ctrl-c を入力してコンテナーを停止します。</p>

<h2 id="run-in-detached-mode">デタッチモードでの実行</h2>

<p>ここまでの作業は順調です。
しかしサンプルアプリケーションはウェブサーバーであって、コンテナーに接続したターミナルを操作する必要がありませんでした。
Docker ではコンテナーをデタッチモードにより、つまりバックグラウンドで実行することができます。
これを行うには<code class="language-plaintext highlighter-rouge">--detach</code>フラグ、あるいは短く<code class="language-plaintext highlighter-rouge">-d</code>を指定します。
Docker はコンテナー起動を同様に行いますが、ただしこの場合、コンテナーからは「デタッチされている」（切り離されている）ので、ターミナルプロンプトに戻ります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 8000:8000 node-docker
ce02b3179f0f10085db9edfccd731101868f58631bdf918ca490ff6fd223a93b
</code></pre></div></div>

<p>Docker がバックグラウンドでコンテナーを起動した後は、ターミナル上にコンテナー ID が表示されます。</p>

<p>同じようにコンテナーが適切に動作していることを確認します。
上と同じ curl コマンドを実行します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">--request</span> POST <span class="se">\</span>
  <span class="nt">--url</span> http://localhost:8000/test <span class="se">\</span>
  <span class="nt">--header</span> <span class="s1">'content-type: application/json'</span> <span class="se">\</span>
  <span class="nt">--data</span> <span class="s1">'{
	"msg": "testing"
}'</span>
<span class="o">{</span><span class="s2">"code"</span>:<span class="s2">"success"</span>,<span class="s2">"payload"</span>:[<span class="o">{</span><span class="s2">"msg"</span>:<span class="s2">"testing"</span>,<span class="s2">"id"</span>:<span class="s2">"dc0e2c2b-793d-433c-8645-b3a553ea26de"</span>,<span class="s2">"createDate"</span>:<span class="s2">"2020-09-01T17:36:09.897Z"</span><span class="o">}]}</span>
</code></pre></div></div>

<h2 id="list-containers">コンテナー一覧</h2>

<p>バックグラウンドでコンテナーを実行しました。
ではコンテナーが起動していることや、他にどんなコンテナーが起動しているかは、どうやって確認したらよいでしょう？
答えは<code class="language-plaintext highlighter-rouge">docker ps</code>コマンドを実行することです。
まさに Linux において、マシン上のプロセス一覧を確認するために ps コマンドを実行することと同じです。
同じ考え方で<code class="language-plaintext highlighter-rouge">docker ps</code>コマンドを実行し、マシン上において実行しているコンテナーの一覧を確認します。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
ce02b3179f0f        node-docker         "docker-entrypoint.s…"   6 minutes ago       Up 6 minutes        0.0.0.0:8000-&gt;8000/tcp   wonderful_kalam
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ps</code>コマンドは実行中のコンテナーに関するさまざまな情報を表示します。
その情報の中にはコンテナー ID があります。
さらに、コンテナー内部で実行されているイメージ、コンテナー起動に用いられたコマンド、生成された時刻、ステータス、公開ポート、コンテナー名が見てとれます。</p>

<p>コンテナー名はどうやって決まったのかと不思議に思うかもしれません。
コンテナーの起動時にはコンテナー名を指定しませんでした。
その場合 Docker はランダムな名前を生成します。
これはこの後すぐに調整しますが、そのためにはまずコンテナーの停止が必要です。
コンテナーの停止は<code class="language-plaintext highlighter-rouge">docker stop</code>コマンドを用います。
このコマンドはまさにコンテナーを停止するだけです。
コマンド実行時にはコンテナー名を指定することが必要ですが、コンテナー ID を指定することもできます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker stop wonderful_kalam
wonderful_kalam
</code></pre></div></div>

<p>もう一度<code class="language-plaintext highlighter-rouge">docker ps</code>コマンドを実行して、実行中コンテナーの一覧を確認します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre></div></div>

<h2 id="stop-start-and-name-containers">コンテナーの停止、起動、名前づけ</h2>

<p>Docker コンテナーは起動、停止、再起動を行うことができます。
コンテナーを停止しても、コンテナーは削除されず、ステータスが停止というものに変わります。
コンテナー内部のプロセスは停止します。
<code class="language-plaintext highlighter-rouge">docker ps</code>コマンドを実行したとき、デフォルトで表示されるのは実行中コンテナーのみです。
<code class="language-plaintext highlighter-rouge">--all</code>フラグあるいは短く<code class="language-plaintext highlighter-rouge">-a</code>を指定すれば、実行中か停止中に関係なく、システムのすべてのコンテナーが表示されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps <span class="nt">-a</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES
ce02b3179f0f        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   16 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> 5 minutes ago                        wonderful_kalam
ec45285c456d        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   28 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> 20 minutes ago                       agitated_moser
fb7a41809e5d        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   37 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> 36 minutes ago                       goofy_khayyam
</code></pre></div></div>

<p>この先に進んでいくにつれて、いろいろなコンテナーが一覧表示されます。
それは起動したり停止したりしたコンテナーであり、削除したものはそこに含まれません。</p>

<p>先ほど停止したコンテナーを再起動してみます。
停止した際のコンテナー名を用いて、以下の restart コマンドのコンテナー名を置き換えて実行してください。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker restart wonderful_kalam
</code></pre></div></div>

<p>そこで ps コマンドをもう一度実行して、コンテナー一覧を確認します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps <span class="nt">--all</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES
ce02b3179f0f        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   19 minutes ago      Up 8 seconds                0.0.0.0:8000-&gt;8000/tcp   wonderful_kalam
ec45285c456d        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   31 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> 23 minutes ago                            agitated_moser
fb7a41809e5d        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   40 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> 39 minutes ago                            goofy_khayyam
</code></pre></div></div>

<p>restart したコンテナーはデタッチモードで起動されていて、ポート 80 が公開されています。
さらにコンテナーのステータス欄を見ると「Up X seconds」となっています。
コンテナーを再起動した場合には、もともと起動されたときと同じフラグやコマンドを使って起動されます。</p>

<p>これまでのコンテナーをすべて停止して削除してみます。
そしてランダムな名称となる問題を調整する作業に入っていきます。</p>

<p>起動したコンテナーを停止してください。
システム上において実行中のコンテナーの名前を確認して、これを以下のコマンドに与えるコンテナー名として置き換えて実行します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker stop wonderful_kalam
wonderful_kalam
</code></pre></div></div>

<p>これでコンテナーはすべて停止されたので削除を行います。
コンテナーを削除すると、そこから先、起動中にも停止中にもなりません。
コンテナー内部のプロセスは停止していて、コンテナーに対するメタデータも削除されています。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker ps <span class="nt">--all</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES
ce02b3179f0f        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   19 minutes ago      Up 8 seconds                0.0.0.0:8000-&gt;8000/tcp   wonderful_kalam
ec45285c456d        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   31 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> 23 minutes ago                            agitated_moser
fb7a41809e5d        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   40 minutes ago      Exited <span class="o">(</span>0<span class="o">)</span> 39 minutes ago                            goofy_khayyam
</code></pre></div></div>

<p>コンテナーを削除するには、<code class="language-plaintext highlighter-rouge">docker rm</code>コマンドにコンテナー名を与えて実行します。
複数のコンテナー名を指定して 1 度のコマンドで削除することもできます。</p>

<p>再度、以下のコマンドにおいて、コンテナー名をシステム内の実際のコンテナー名に置き換えて実行してください。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">rm </span>wonderful_kalam agitated_moser goofy_khayyam
wonderful_kalam
agitated_moser
goofy_khayyam
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">docker ps --all</code>コマンドを実行して、コンテナーがすべてなくなったことを確認します。</p>

<p>それではランダムな名称が用いられてしまう面倒な問題に対処していきます。
ごく標準的にはコンテナーに対して名前づけを行います。
これは単純に、コンテナー内で実行されているものが何であるか、どんなアプリケーションやサービスが関連づいているのか、といったことが確認しやすくなるからです。
アプリケーションコードにおいて変数の命名規則のようなものを利用すれば、非常に理解しやすいものになります。
そこでコンテナーへの名前づけを行っていきます。</p>

<p>コンテナーに名前をつけるには run コマンドにおいて<code class="language-plaintext highlighter-rouge">--name</code>フラグを指定するだけです。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 8000:8000 <span class="nt">--name</span> rest-server node-docker
1aa5d46418a68705c81782a58456a4ccdb56a309cb5e6bd399478d01eaa5cdda
<span class="nv">$ </span>docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
1aa5d46418a6        node-docker         <span class="s2">"docker-entrypoint.s…"</span>   3 seconds ago       Up 3 seconds        0.0.0.0:8000-&gt;8000/tcp   rest-server
</code></pre></div></div>

<p>名前に基づいてコンテナーが簡単に識別できるようになります。</p>

<h2 id="conclusion">まとめ</h2>

<p>このチュートリアルでは、コンテナーの実行、ポートの公開、デタッチモードでのコンテナー実行をそれぞれ見てきました。
またコンテナー起動、停止、再起動の制御方法を見ました。
そしてコンテナーへの名前づけを行って、コンテナーの識別がわかりやすくなりました。</p>

<p>次のチュートリアルでは、<a href="/docs.docker.jp.onthefly/get-started/nodejs/develop/">コンテナー内でのデータベース実行</a> を行って、アプリケーションにデータベースを接続してみます。</p>
