<ul class="pagination">
  <li><a href="/docs.docker.jp.onthefly/get-started/nodejs/build-images/">イメージのビルド</a></li>
  <li><a href="/docs.docker.jp.onthefly/get-started/nodejs/run-containers/">イメージのコンテナーとしての実行</a></li>
  <li class="active"><a href="/docs.docker.jp.onthefly/get-started/nodejs/develop/">開発向けのコンテナー利用</a></li>
</ul>

<h2 id="prerequisites">前提条件</h2>

<p><a href="/docs.docker.jp.onthefly/get-started/nodejs/run-containers/">イメージのコンテナーとしての実行</a> を通じて、コンテナー化したアプリケーションであるイメージのビルドと実行を行っていること。</p>

<h2 id="introduction">はじめに</h2>

<p>このチュートリアルでは、その前で作ったアプリケーションの開発環境をローカルに構築する手順を進めていきます。
Docker を使ってイメージをビルドするとともに Docker Compose を使って、あらゆるものを簡単に取り扱っていきます。</p>

<h2 id="use-compose-to-develop-locally">Compose を使ったローカル開発</h2>

<p>notes-service プロジェクトは、データストアとして MongoDB を利用します。
本チュートリアルの 1 部からわかるように、Mongo コンテナーは手動で起動して、notes-service が起動している同一のネットワークに接続しなければなりません。
またボリュームをいくつか生成してデータ保存を行います。
こうすることでアプリケーションや MongoDB の再起動を行っても、データが失われないようにします。</p>

<p>本節では Compose ファイルを生成して node-docker と MongoDB を 1 つのコマンドで起動していきます。
さらに Compose ファイルにおいては node-docker をデバッグモードで起動するように設定して、実行中のノードプロセスにデバッガーから接続します。</p>

<p>IDE またはテキストエディターにより notes-service を開いて、<code class="language-plaintext highlighter-rouge">docker-compose.dev.yml</code>という新規ファイルを生成します。
そしてそのファイルに以下のコードをコピーペーストしてください。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.8'</span>

<span class="na">services</span><span class="pi">:</span>
 <span class="na">notes</span><span class="pi">:</span>
   <span class="na">build</span><span class="pi">:</span>
     <span class="na">context</span><span class="pi">:</span> <span class="s">.</span>
   <span class="na">ports</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">8080:8080</span>
     <span class="pi">-</span> <span class="s">9229:9229</span>
   <span class="na">environment</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">SERVER_PORT=8080</span>
     <span class="pi">-</span> <span class="s">DATABASE_CONNECTIONSTRING=mongodb://mongo:27017/notes</span>
   <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">./:/code</span>
   <span class="na">command</span><span class="pi">:</span> <span class="s">npm run debug</span>

 <span class="na">mongo</span><span class="pi">:</span>
   <span class="na">image</span><span class="pi">:</span> <span class="s">mongo:4.2.8</span>
   <span class="na">ports</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">27017:27017</span>
   <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">mongodb:/data/db</span>
     <span class="pi">-</span> <span class="s">mongodb_config:/data/configdb</span>
 <span class="na">volumes</span><span class="pi">:</span>
   <span class="na">mongodb</span><span class="pi">:</span>
   <span class="na">mongodb_config</span><span class="pi">:</span>
</code></pre></div></div>

<p>この Compose ファイルはとても優れていて、<code class="language-plaintext highlighter-rouge">docker run</code>コマンドにパラメーターを入力する面倒をなくしてくれます。
Compose ファイル内では、すべてを宣言的に記述していきます。</p>

<p>デバッガーをアタッチできるように、ポート 9229 を公開します。
さらにローカルにあるソースコードを実行中のコンテナーにマッピングして、テキストエディター上でのソース変更を可能とし、さらにその変更をコンテナーが察知できるようにします。</p>

<p>Compose ファイルを利用する際の優れた機能として、サービスの名前を使っただけでサービス指定ができる点が挙げられます。
そこで指定文字として「mongo」を利用します。
mongo という文字を使うのは、Compose ファイルにおいて mongo サービスに対して、そのように命名したからです。</p>

<p>アプリケーションを起動して、正常に動作することを確認します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose <span class="nt">-f</span> docker-compose.dev.yml up <span class="nt">--build</span>
</code></pre></div></div>

<p>ここで<code class="language-plaintext highlighter-rouge">--build</code>フラグを与えています。
これは Docker がイメージをコンパイルした上で起動するようにします。</p>

<p>うまく動作すれば、以下と同様に表示されます。</p>

<p><img src="/docs.docker.jp.onthefly/get-started/nodejs/images/node-compile.png" alt="node-compile" /></p>

<p>API エンドポイントをテストしてみます。
以下の curl コマンドを実行してください。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">--request</span> GET <span class="nt">--url</span> http://localhost:8080/services/m/notes
</code></pre></div></div>

<p>以下のようなレスポンスが返ってくるはずです。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"code"</span><span class="p">:</span><span class="s2">"success"</span><span class="p">,</span><span class="nl">"meta"</span><span class="p">:{</span><span class="nl">"total"</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nl">"count"</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span><span class="nl">"payload"</span><span class="p">:[]}</span><span class="w">
</span></code></pre></div></div>

<h2 id="connect-a-debugger">デバッガーへの接続</h2>

<p>ここで Chrome ブラウザーに付属しているデバッガーを利用することにします。
マシン上において Chrome ブラウザーを開き、アドレスバーに以下を入力します。</p>

<p><code class="language-plaintext highlighter-rouge">about:inspect</code></p>

<p>以下の画面が開きます。</p>

<p><img src="/docs.docker.jp.onthefly/get-started/nodejs/images/chrome-inspect.png" alt="Chrome-inspect" /></p>

<p><strong>Open dedicated DevTools for Node</strong>（Node 専用の DevTools を開く）リンクをクリックします。
これにより DevTools が開きます。
このツールは、コンテナー内部で稼動している Node.js プロセスに接続されています。</p>

<p>ソースコードを変更し、ブレークポイントを設定してみます。</p>

<p>server.js ファイルの 19 行めに以下のコードを追加して、ファイルを保存します。</p>

<pre><code class="language-node"> server.use( '/foo', (req, res) =&gt; {
   return res.json({ "foo": "bar" })
 })
</code></pre>

<p>Compose アプリケーションを実行しているターミナルを確認してみると、nodemon が変更を検出して、アプリケーションをリロードしているのがわかります。</p>

<p><img src="/docs.docker.jp.onthefly/get-started/nodejs/images/nodemon.png" alt="nodemon" /></p>

<p>Chrome のDevTools 画面に戻って、20 行目にブレークポイントを設定します。
そして以下の curl コマンドを実行してブレークポイントまで進めます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">--request</span> GET <span class="nt">--url</span> http://localhost:8080/foo
</code></pre></div></div>

<p>コードの 20 行目でブレークされたはずです。
ここから普段使っている方法でデバッガーを操作できるようになります。
変数を詳細に確認しウォッチすることや条件つきブレークポイントの設定、スタックトレースの確認などを行うことができます。</p>

<h2 id="conclusion">まとめ</h2>

<p>本稿を通じて、汎用的な開発イメージの生成方法を見てきました。
それは普通のコマンドラインから実行することと全く同じことです。
Compose ファイルを生成して、ソースコードを実行コンテナー内にマッピングし、デバッグ用のポート公開も行いました。</p>
