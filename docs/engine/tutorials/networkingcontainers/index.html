
<p>ユーザーガイドに従って作業を進めてきたら、単純なアプリケーションはビルドし実行できているはずです。
また自分の Docker イメージもビルドできているでしょう。
ここではそのコンテナーに対するネットワーク設定方法について説明します。</p>

<h2 id="launch-a-container-on-the-default-network">デフォルトネットワークによるコンテナーの起動</h2>

<p>Docker では <strong>ネットワークドライバー</strong> を用いて、コンテナーのネットワーク設定を行う機能がサポートされています。
デフォルトで提供されているネットワークドライバーは 2 つ、つまり <code class="language-plaintext highlighter-rouge">bridge</code> ドライバーと <code class="language-plaintext highlighter-rouge">overlay</code> ドライバーです。
ネットワークドライバーはプラグインとして記述することが可能であり、独自のドライバーを生成することができます。
ただしこれは高度な作業になります。</p>

<p>Docker Engine をインストールしたときには、自動的に 3 つのデフォルトネットワークが生成されます。
その一覧は以下のようにして見ることができます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network ls

NETWORK ID          NAME                DRIVER
18a2866682b8        none                null
c288470c46f6        host                host
7b369448dccb        bridge              bridge
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">bridge</code> という名前のネットワークは特別なものです。
ネットワークに関しての指定を行わなければ、Docker は常にこのネットワーク内にコンテナーを起動します。
このことを試してみます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -itd --name=networktest ubuntu

74695c9cea6d9810718fddadc01a727a5dd3ce6a69d09752239736c030599741
</code></pre></div></div>

<p><img src="/docs.docker.jp.onthefly/engine/tutorials/bridge1.png" alt="bridge1" /></p>

<p>ネットワークを調べてみれば、コンテナーの IP アドレスは簡単に分かります。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network inspect bridge

<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Name"</span>: <span class="s2">"bridge"</span>,
        <span class="s2">"Id"</span>: <span class="s2">"f7ab26d71dbd6f557852c7156ae0574bbf62c42f539b50c8ebde0f728a253b6f"</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"bridge"</span>,
        <span class="s2">"EnableIPv6"</span>: <span class="nb">false</span>,
        <span class="s2">"IPAM"</span>: <span class="o">{</span>
            <span class="s2">"Driver"</span>: <span class="s2">"default"</span>,
            <span class="s2">"Options"</span>: null,
            <span class="s2">"Config"</span>: <span class="o">[</span>
                <span class="o">{</span>
                    <span class="s2">"Subnet"</span>: <span class="s2">"172.17.0.1/16"</span>,
                    <span class="s2">"Gateway"</span>: <span class="s2">"172.17.0.1"</span>
                <span class="o">}</span>
            <span class="o">]</span>
        <span class="o">}</span>,
        <span class="s2">"Internal"</span>: <span class="nb">false</span>,
        <span class="s2">"Containers"</span>: <span class="o">{</span>
            <span class="s2">"3386a527aa08b37ea9232cbcace2d2458d49f44bb05a6b775fba7ddd40d8f92c"</span>: <span class="o">{</span>
                <span class="s2">"Name"</span>: <span class="s2">"networktest"</span>,
                <span class="s2">"EndpointID"</span>: <span class="s2">"647c12443e91faf0fd508b6edfe59c30b642abb60dfab890b4bdccee38750bc1"</span>,
                <span class="s2">"MacAddress"</span>: <span class="s2">"02:42:ac:11:00:02"</span>,
                <span class="s2">"IPv4Address"</span>: <span class="s2">"172.17.0.2/16"</span>,
                <span class="s2">"IPv6Address"</span>: <span class="s2">""</span>
            <span class="o">}</span>
        <span class="o">}</span>,
        <span class="s2">"Options"</span>: <span class="o">{</span>
            <span class="s2">"com.docker.network.bridge.default_bridge"</span>: <span class="s2">"true"</span>,
            <span class="s2">"com.docker.network.bridge.enable_icc"</span>: <span class="s2">"true"</span>,
            <span class="s2">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="s2">"true"</span>,
            <span class="s2">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="s2">"0.0.0.0"</span>,
            <span class="s2">"com.docker.network.bridge.name"</span>: <span class="s2">"docker0"</span>,
            <span class="s2">"com.docker.network.driver.mtu"</span>: <span class="s2">"9001"</span>
        <span class="o">}</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>

<p>ネットワークからコンテナーを削除するには、そのコンテナーを切り離すことで行います。
そのときには、ネットワーク名とコンテナー名を両方指定します。
あるいはコンテナー ID を用いることもできます。
以下の例では、名前を用いるのが簡単なので、名前を指定します。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network disconnect bridge networktest
</code></pre></div></div>

<p>ネットワークからコンテナーを切り離すことはできますが、ビルトインの <code class="language-plaintext highlighter-rouge">bridge</code> ネットワークを削除することはできません。
他のコンテナーや他のネットワークから、目的のコンテナーを独立させるようなネットワークとすることは、よく行うことです。
そこで Docker について十分に経験を積んだ方は、独自のネットワークを生成してください。</p>

<h2 id="create-your-own-bridge-network">ブリッジネットワークの生成</h2>

<p>Docker Engine は、ブリッジネットワークとオーバーレイネットワークを両方ともサポートしています。
ブリッジネットワークは Docker Engine が稼動する単一ホストでの利用に限定されます。
オーバーレイネットワークは複数ホストを含めることが可能であり、より高度な手段です。
以下の例ではブリッジネットワークを生成します。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network create -d bridge my_bridge
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-d</code> フラグは、新たなネットワークに対して <code class="language-plaintext highlighter-rouge">bridge</code> ドライバーを利用することを指示するものです。
このフラグは省略することができます。
<code class="language-plaintext highlighter-rouge">bridge</code> がこのフラグのデフォルト値であるからです。
次にマシン上のネットワークの一覧を確認します。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network ls

NETWORK ID          NAME                DRIVER
7b369448dccb        bridge              bridge
615d565d498c        my_bridge           bridge
18a2866682b8        none                null
c288470c46f6        host                host
</code></pre></div></div>

<p>ネットワークを調べてみると、中には何も入っていません。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network inspect my_bridge

[
    {
        "Name": "my_bridge",
        "Id": "5a8afc6364bccb199540e133e63adb76a557906dd9ff82b94183fc48c40857ac",
        "Scope": "local",
        "Driver": "bridge",
        "IPAM": {
            "Driver": "default",
            "Config": [
                {
                    "Subnet": "10.0.0.0/24",
                    "Gateway": "10.0.0.1"
                }
            ]
        },
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]
</code></pre></div></div>

<h2 id="ネットワークへのコンテナーの追加">ネットワークへのコンテナーの追加</h2>

<p>ウェブアプリケーションを構築する際に、まわりと連携動作をしつつ、十分に安全に動作させるためには、ネットワークを生成します。
ネットワークとは元々の意味からすれば、コンテナーを完全に独立して取り扱うものです。
ネットワークへのコンテナー追加は、コンテナーを起動するときに行うことができます。</p>

<p>PostgreSQL データベースを実行するコンテナーを起動させ、その際に <code class="language-plaintext highlighter-rouge">--net=my_bridge</code> フラグを与えます。
こうして指定したネットワークに接続されます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -d --net=my_bridge --name db training/postgres
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">my_bridge</code> を調べてみると、コンテナーが接続されているのがわかります。
逆にコンテナーを調べてみると、どこに接続しているかもわかります。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker inspect --format='{{json .NetworkSettings.Networks}}'  db


{"my_bridge":{"NetworkID":"7d86d31b1478e7cca9ebed7e73aa0fdeec46c5ca29497431d3007d2d9e15ed99",
"EndpointID":"508b170d56b2ac9e4ef86694b0a76a22dd3df1983404f7321da5649645bf7043","Gateway":"10.0.0.1","IPAddress":"10.0.0.254","IPPrefixLen":24,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:11:00:02"}}
</code></pre></div></div>

<p>そこで次に、おなじみのウェブアプリケーションを起動してみます。
ここではネットワークを指定しません。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -d --name web training/webapp python app.py
</code></pre></div></div>

<p><img src="/docs.docker.jp.onthefly/engine/tutorials/bridge2.png" alt="bridge2" /></p>

<p><code class="language-plaintext highlighter-rouge">web</code> アプリケーションはどのネットワーク上にあるでしょう？
アプリケーションを調べてみてください。
これはデフォルトの <code class="language-plaintext highlighter-rouge">bridge</code> ネットワーク上に稼動しています。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker inspect --format='{{json .NetworkSettings.Networks}}'  web


{"bridge":{"NetworkID":"7ea29fc1412292a2d7bba362f9253545fecdfa8ce9a6e37dd10ba8bee7129812",
"EndpointID":"508b170d56b2ac9e4ef86694b0a76a22dd3df1983404f7321da5649645bf7043","Gateway":"172.17.0.1","IPAddress":"10.0.0.2","IPPrefixLen":24,"IPv6Gateway":"","GlobalIPv6Address":"","GlobalIPv6PrefixLen":0,"MacAddress":"02:42:ac:11:00:02"}}
</code></pre></div></div>

<p>そこで <code class="language-plaintext highlighter-rouge">web</code> の IP アドレスを取得します。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web


172.17.0.2
</code></pre></div></div>

<p>稼動している <code class="language-plaintext highlighter-rouge">db</code> コンテナーに対してシェルを開きます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker container exec -it db bash

root@a205f0dd33b2:/# ping 172.17.0.2
ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
^C
--- 172.17.0.2 ping statistics ---
44 packets transmitted, 0 received, 100% packet loss, time 43185ms
</code></pre></div></div>

<p>少ししたら、<code class="language-plaintext highlighter-rouge">CTRL-C</code> により <code class="language-plaintext highlighter-rouge">ping</code> を終了させます。
ping は失敗しているのがわかります。
これは 2 つのコンテナーが別々のネットワーク上で動作しているからです。
これを修正します。
まずは <code class="language-plaintext highlighter-rouge">exit</code> コマンドを実行して、コンテナーへのアクセスを閉じます。</p>

<p>Docker のネットワーク機能では、複数のネットワークを必要に応じて 1 つのコンテナーに割り当てることができます。
すでに稼動済のコンテナーであっても割り当てられます。
次は稼動している <code class="language-plaintext highlighter-rouge">web</code> アプリを <code class="language-plaintext highlighter-rouge">my_bridge</code> に割り当てます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network connect my_bridge web
</code></pre></div></div>

<p><img src="/docs.docker.jp.onthefly/engine/tutorials/bridge3.png" alt="bridge3" /></p>

<p>もう一度、稼動している <code class="language-plaintext highlighter-rouge">db</code> コンテナーに対してシェルを開きます。
そして ping コマンドを入力してみます。
今回は IP アドレスではなく、コンテナー名 <code class="language-plaintext highlighter-rouge">web</code> を用います。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker container exec -it db bash

root@a205f0dd33b2:/# ping web
PING web (10.0.0.2) 56(84) bytes of data.
64 bytes from web (10.0.0.2): icmp_seq=1 ttl=64 time=0.095 ms
64 bytes from web (10.0.0.2): icmp_seq=2 ttl=64 time=0.060 ms
64 bytes from web (10.0.0.2): icmp_seq=3 ttl=64 time=0.066 ms
^C
--- web ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2000ms
rtt min/avg/max/mdev = 0.060/0.073/0.095/0.018 ms
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ping</code> の結果から、別の IP アドレスに接続しているのがわかります。
<code class="language-plaintext highlighter-rouge">my_bridge</code> 上にあるアドレスは、<code class="language-plaintext highlighter-rouge">bridge</code> ネットワーク上のアドレスとは異なっているわけです。</p>

<h2 id="次のステップ">次のステップ</h2>

<p>コンテナーのネットワーク設定方法がわかったら、次は <a href="/docs.docker.jp.onthefly/storage/volumes/">コンテナーにおけるデータ管理方法</a> に進んでください。</p>
