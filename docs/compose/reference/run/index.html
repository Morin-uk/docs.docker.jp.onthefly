<pre><code class="language-none">Usage:
    run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] [-l KEY=VALUE...]
        SERVICE [COMMAND] [ARGS...]

Options:
    -d, --detach          Detached mode: Run container in the background, print
                          new container name.
    --name NAME           Assign a name to the container
    --entrypoint CMD      Override the entrypoint of the image.
    -e KEY=VAL            Set an environment variable (can be used multiple times)
    -l, --label KEY=VAL   Add or override a label (can be used multiple times)
    -u, --user=""         Run as specified username or uid
    --no-deps             Don't start linked services.
    --rm                  Remove container after run. Ignored in detached mode.
    -p, --publish=[]      Publish a container's port(s) to the host
    --service-ports       Run command with the service's ports enabled and mapped
                          to the host.
    --use-aliases         Use the service's network aliases in the network(s) the
                          container connects to.
    -v, --volume=[]       Bind mount a volume (default [])
    -T                    Disable pseudo-tty allocation. By default `docker-compose run`
                          allocates a TTY.
    -w, --workdir=""      Working directory inside the container
</code></pre>

<p>Runs a one-time command against a service. For example, the following command starts the <code class="language-plaintext highlighter-rouge">web</code> service and runs <code class="language-plaintext highlighter-rouge">bash</code> as its command.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose run web bash
</code></pre></div></div>

<p>Commands you use with <code class="language-plaintext highlighter-rouge">run</code> start in new containers with configuration defined by that of the service, including volumes, links, and other details. However, there are two important differences.</p>

<p>First, the command passed by <code class="language-plaintext highlighter-rouge">run</code> overrides the command defined in the service configuration. For example, if the  <code class="language-plaintext highlighter-rouge">web</code> service configuration is started with <code class="language-plaintext highlighter-rouge">bash</code>, then <code class="language-plaintext highlighter-rouge">docker-compose run web python app.py</code> overrides it with <code class="language-plaintext highlighter-rouge">python app.py</code>.</p>

<p>The second difference is that the <code class="language-plaintext highlighter-rouge">docker-compose run</code> command does not create any of the ports specified in the service configuration. This prevents port collisions with already-open ports. If you <em>do want</em> the service’s ports to be created and mapped to the host, specify the <code class="language-plaintext highlighter-rouge">--service-ports</code> flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose run --service-ports web python manage.py shell
</code></pre></div></div>

<p>Alternatively, manual port mapping can be specified with the <code class="language-plaintext highlighter-rouge">--publish</code> or <code class="language-plaintext highlighter-rouge">-p</code> options, just as when using <code class="language-plaintext highlighter-rouge">docker run</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose run --publish 8080:80 -p 2022:22 -p 127.0.0.1:2021:21 web python manage.py shell
</code></pre></div></div>

<p>If you start a service configured with links, the <code class="language-plaintext highlighter-rouge">run</code> command first checks to see if the linked service is running and starts the service if it is stopped.  Once all the linked services are running, the <code class="language-plaintext highlighter-rouge">run</code> executes the command you passed it. For example, you could run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose run db psql -h db -U docker
</code></pre></div></div>

<p>This opens an interactive PostgreSQL shell for the linked <code class="language-plaintext highlighter-rouge">db</code> container.</p>

<p>If you do not want the <code class="language-plaintext highlighter-rouge">run</code> command to start linked containers, use the <code class="language-plaintext highlighter-rouge">--no-deps</code> flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose run --no-deps web python manage.py shell
</code></pre></div></div>

<p>If you want to remove the container after running while overriding the container’s restart policy, use the <code class="language-plaintext highlighter-rouge">--rm</code> flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose run --rm web python manage.py db upgrade
</code></pre></div></div>

<p>This runs a database upgrade script, and removes the container when finished running, even if a restart policy is specified in the service configuration.</p>
