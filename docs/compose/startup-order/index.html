
<p>サービスの起動順や停止順は、<a href="/docs.docker.jp.onthefly/compose/compose-file/#depends_on">depends_on</a> オプションを使って制御することができます。
Compose では必ず依存順に応じて、コンテナーの起動または停止を行いますが、この依存順とは <code class="language-plaintext highlighter-rouge">depends_on</code>、<code class="language-plaintext highlighter-rouge">links</code>、<code class="language-plaintext highlighter-rouge">volumes_from</code>、<code class="language-plaintext highlighter-rouge">network_mode: "service:..."</code> によって決定します。</p>

<p>しかし起動時の場合、Compose はコンテナーが “準備状態” になって初めて制御を待ちます。
（これがアプリケーションにとってどのような意味になるかには無関係です。）
つまり稼動していることが必要です。
これには十分な理由があります。</p>

<p>たとえばデータベースが準備状態になるまで待ち続けたとすると、分散システムにおいては非常に大きな問題となります。
本番環境であれば利用不能となって、すぐにホストを切り替えなければならなくなります。
アプリケーションは、このような状況に柔軟に対応できるものでなくてはなりません。</p>

<p>こういったことを取り扱う際には、データベースへの接続に失敗した後に、接続を再度確立するようにアプリケーションを設計しておくことが必要です。
アプリケーションが再接続を行えば、そのうちデータベースへの接続が成功します。</p>

<p>最適な方法は、再接続をアプリケーションコード内で行うことです。
これは起動時にも行い、さらに何らかの理由で接続が断たれた際にも行います。
もっともそれほどの柔軟性を必要としないのであれば、以下のようなラッパースクリプトを使ってこの問題を回避する方法もあります。</p>

<ul>
  <li>
    <p><a href="https://github.com/vishnubob/wait-for-it">wait-for-it</a>、
<a href="https://github.com/jwilder/dockerize">dockerize</a>、シェル互換の <a href="https://github.com/Eficode/wait-for">wait-for</a>、<a href="https://github.com/jasonsychau/RelayAndContainers">RelayAndContainers</a> テンプレートを利用します。
これは非常に小さなラッパースクリプトです。
これをアプリケーションイメージに含めて、指定されたホストが TCP 接続を受け入れるまでの間、指定ポートに問い合わせを行うようにすることができます。</p>

    <p>たとえば <code class="language-plaintext highlighter-rouge">wait-for-it.sh</code> または <code class="language-plaintext highlighter-rouge">wait-for</code> を使って、サービスコマンドをラップするには以下のようにします。</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:8000"</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">db"</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">./wait-for-it.sh"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">db:5432"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">--"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">python"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">app.py"</span><span class="pi">]</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
</code></pre></div>    </div>

    <blockquote>
      <p><strong>ヒント</strong></p>

      <p>この解決方法には限界があります。
たとえば指定するサービスが、本当に準備状態であるかどうかは確認できません。
コマンドにさらに引数を追加して <code class="language-plaintext highlighter-rouge">bash shift</code> を利用し、ループによって対処するのが次の例です。</p>
    </blockquote>
  </li>
  <li>
    <p>別の方法として、独自にラッパースクリプトを用意して、アプリケーション特有のヘルスチェックを実現することも考えられます。
たとえば Postgres が完全に準備状態になって、コマンドを受け付けるようになるまで待ちたいとするなら、以下のスクリプトを用意します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
<span class="c"># wait-for-postgres.sh</span>

<span class="nb">set</span> <span class="nt">-e</span>

<span class="nv">host</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
<span class="nb">shift
</span><span class="nv">cmd</span><span class="o">=</span><span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>

<span class="k">until </span><span class="nv">PGPASSWORD</span><span class="o">=</span><span class="nv">$POSTGRES_PASSWORD</span> psql <span class="nt">-h</span> <span class="s2">"</span><span class="nv">$host</span><span class="s2">"</span> <span class="nt">-U</span> <span class="s2">"postgres"</span> <span class="nt">-c</span> <span class="s1">'\q'</span><span class="p">;</span> <span class="k">do</span>
  <span class="o">&gt;</span>&amp;2 <span class="nb">echo</span> <span class="s2">"Postgres is unavailable - sleeping"</span>
  <span class="nb">sleep </span>1
<span class="k">done</span>

<span class="o">&gt;</span>&amp;2 <span class="nb">echo</span> <span class="s2">"Postgres is up - executing command"</span>
<span class="nb">exec</span> <span class="nv">$cmd</span>
</code></pre></div>    </div>

    <p>このラッパースクリプトを先の例において利用するには、以下のように設定します。</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">./wait-for-postgres.sh"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">db"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">python"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">app.py"</span><span class="pi">]</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="compose-documentation">Compose ドキュメント</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/compose/">ユーザーガイド</a></li>
  <li><a href="/docs.docker.jp.onthefly/compose/install/">Compose のインストール</a></li>
  <li><a href="/docs.docker.jp.onthefly/compose/gettingstarted/">はじめよう</a></li>
  <li><a href="/docs.docker.jp.onthefly/compose/reference/">コマンドラインリファレンス</a></li>
  <li><a href="/docs.docker.jp.onthefly/compose/compose-file/">Compose ファイルリファレンス</a></li>
  <li><a href="/docs.docker.jp.onthefly/compose/samples-for-compose/">Compose を使ったサンプルアプリ</a></li>
</ul>
