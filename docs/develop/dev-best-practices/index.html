
<p>Docker を使ってアプリケーション開発を行う方々にとって、以下に示す開発パターンが有効であることが明らかになっています。
何かを見つけている場合は <a href="https://github.com/docker/docker.github.io/issues/new" target="_blank" rel="noopener" class="_">お知らせください</a>。</p>

<h2 id="how-to-keep-your-images-small">どうやってイメージを小さく保つか</h2>

<p>イメージが小さければネットワークからの取得が速くなります。
またコンテナーやサービスの起動時に、メモリへのロードも速くなります。
イメージを小さく保つ経験則をいくつか示します。</p>

<ul>
  <li>
    <p>適切なイメージをベースとして始めます。
たとえば JDK を必要とするのであれば、公式イメージ <code class="language-plaintext highlighter-rouge">openjdk</code> をベースとしたイメージ作りとします。
逆に、汎用的な <code class="language-plaintext highlighter-rouge">ubuntu</code> イメージから始めて、Dockerfile 内に <code class="language-plaintext highlighter-rouge">openjdk</code> をインストールするような方法は取らないようにします。</p>
  </li>
  <li>
    <p><a href="/docs.docker.jp.onthefly/develop/develop-images/multistage-build/">マルチステージビルド</a> を利用します。
たとえば <code class="language-plaintext highlighter-rouge">maven</code> イメージを使うと Java アプリケーションを構築することができます。
これを <code class="language-plaintext highlighter-rouge">tomcat</code> イメージとして作り直して、Java アプリのコード類を適切な場所に配置してデプロイできるようにします。
これをすべて同一の Dockerfile 内で行います。
これはつまり最終的なイメージがビルドされたら、そのイメージ内には、元々のイメージ取得時に存在していたライブラリや依存パッケージがすべて含まれるわけではなく、実行時に必要なモジュールや環境のみが含まれるということを意味します。</p>

    <ul>
      <li>
        <p>マルチステージビルドの機能を持たない Docker バージョンを使う必要があるときには、イメージ内に作られるレイヤー数を減らすようにしてください。
これは Dockerfile 内での <code class="language-plaintext highlighter-rouge">RUN</code> コマンドの実行が、できるだけ分断されないように、その実行数を最小化します。
これを実現するには、複数の <code class="language-plaintext highlighter-rouge">RUN</code> コマンドはできるだけ 1 つの <code class="language-plaintext highlighter-rouge">RUN</code> コマンドとなるように、シェルの機能を使って互いに連結させます。
たとえば以下のような 2 つのコマンド実行例があったとします。
1 つめのコマンドは、イメージ内に 2 つのレイヤーを生成しますが、2 つめのコマンドはレイヤーが 1 つで済みます。</p>

        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>apt-get <span class="nt">-y</span> update
<span class="k">RUN </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> python
</code></pre></div>        </div>

        <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>apt-get <span class="nt">-y</span> update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> python
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>共有するイメージがたくさんある場合は、<a href="/docs.docker.jp.onthefly/develop/develop-images/baseimages/">ベースイメージ</a> を作ることを考えてみてください。
これを用いてコンポーネントを共有し、これをベースとした独自のイメージを作っていくことができます。
Docker は共通するレイヤーであれば 1 度しかロードする必要がなく、ロードした内容はキャッシュされます。
つまりベースイメージから派生させたイメージは、Docker ホスト上でのメモリ利用が効率よく行われ、ロードもすばやく行われることになります。</p>
  </li>
  <li>
    <p>本番環境向けのイメージはスリムにしたいものの、デバッグは可能にしたいといった場合は、デバッグ環境向けとして、本番環境イメージをベースイメージとすることを考えてみてください。
さらにテストやデバッグツールを加えたい場合でも、本番環境イメージの上に追加ができます。</p>
  </li>
  <li>
    <p>イメージをビルドする場合には、常にわかりやすいタグをつけるようにします。
このタグを用いて、バージョン情報をコード化したり、目的とする用途（たとえば <code class="language-plaintext highlighter-rouge">prod</code> や <code class="language-plaintext highlighter-rouge">test</code> など）や安定性など、いろいろな情報を付与したりします。
こうしておけば、アプリケーションをさまざまな環境にデプロイする際にわかりやすくなります。
自動的に生成される <code class="language-plaintext highlighter-rouge">latest</code> タグには頼らないようにします。</p>
  </li>
</ul>

<h2 id="where-and-how-to-persist-application-data">アプリケーションデータはどこにどう保存するか</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/select-storage-driver/">ストレージドライバー</a> によって、コンテナーの書き込み可能レイヤーへデータ保存を行うことができますが、アプリケーションデータの保存を行うことは<strong>避けます</strong>。
これを行ってしまうと、コンテナーのサイズが増えることになり、I/O 観点で言えば、ボリュームやバインドマウントを用いることに比べて非効率なものになります。</li>
  <li>そのかわりに、データ保存は <a href="/docs.docker.jp.onthefly/storage/volumes/">ボリューム</a> を利用します。</li>
  <li><a href="/docs.docker.jp.onthefly/storage/bind-mounts/">バインドマウント</a> を用いるのが適当な例として、開発時での利用が考えられます。
開発時には、ソースディレクトリや生成したばかりのバイナリを、コンテナー内にマウントしたくなります。
本番環境ではボリュームを利用しますが、本番環境がマウントする同じ場所を、開発環境時はバインドマウントによりマウントします。</li>
  <li>本番環境において、サービスが機密情報を利用している場合、その保存には <a href="/docs.docker.jp.onthefly/engine/swarm/secrets/">secrets</a> を利用します。
そして機密情報ではない設定ファイルなどの情報は <a href="/docs.docker.jp.onthefly/engine/swarm/configs/">configs</a> を利用します。
今利用しているコンテナーがスタンドアロンである場合は、1 つのレプリカからなるサービスコンテナーに移行することを考えてみてください。
これを行うと、サービスコンテナーのみに提供される機能を活用することができます。</li>
</ul>

<h2 id="use-cicd-for-testing-and-deployment">テストやデプロイ時の CI/CD 利用</h2>

<ul>
  <li>
    <p>ソース管理上の変更を確認したりプルリクエストを生成したりする場合には、<a href="/docs.docker.jp.onthefly/docker-hub/builds/">Docker Hub</a> やこれに似た別の CI/CD を利用し、自動的なイメージビルド、タグづけ、テストを行うようにしてください。</p>
  </li>
  <li>
    <p>開発、テスト、セキュリティチームによる <a href="/docs.docker.jp.onthefly/engine/reference/commandline/trust/">イメージ認証</a> といった必要に応じて、上のことをより一層進め、 本番環境へのデプロイを行ってください。
こうする場合に、イメージを本番環境にデプロイするのであれば、たとえば開発、品質管理、セキュリティの各チームにおいて十分にテストされ承認されていなければなりません。</p>
  </li>
</ul>

<h2 id="differences-in-development-and-production-environments">開発環境と本番環境の違い</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">開発環境</th>
      <th style="text-align: left">本番環境</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">バインドマウントを用いて、コンテナーからソースコードへアクセスできるようにします。</td>
      <td style="text-align: left">ボリュームを利用してコンテナーデータを保存します。</td>
    </tr>
    <tr>
      <td style="text-align: left">Docker Desktop for Mac または Docker Desktop for Windows を利用します。</td>
      <td style="text-align: left">可能であれば Docker EE を利用してください。<a href="/docs.docker.jp.onthefly/engine/security/userns-remap/">userns mapping</a> を利用すると、ホストプロセスからの Docker プロセスの独立性をさらに高めることになります。</td>
    </tr>
    <tr>
      <td style="text-align: left">時間のずれは、気にする必要はありません。</td>
      <td style="text-align: left">Docker ホスト上、あるいは各コンテナープロセス内においては NTP クライアントを常時稼動させてください。そして同一の NTP サーバーによって同期をとるようにしてください。スウォームサービスを用いる場合、各 Docker ノードは、コンテナーとして同一時刻となるように同期をとるようにしてください。</td>
    </tr>
  </tbody>
</table>
