<p>On this page, you get an overview of the Notary service architecture.</p>

<h2 id="brief-overview-of-tuf-keys-and-roles">Brief overview of TUF keys and roles</h2>

<p>This document assumes familiarity with
<a href="https://www.theupdateframework.com/" target="_blank" rel="noopener" class="_">The Update Framework</a>,
but here is a brief recap of the TUF roles and corresponding key hierarchy:</p>

<p><img src="https://cdn.rawgit.com/docker/notary/09f81717080f53276e6881ece57cbbbf91b8e2a7/docs/images/key-hierarchy.svg" alt="TUF Key Hierarchy" width="400px" /></p>

<ul>
  <li>
    <p>The root key is the root of all trust. It signs the
<a href="https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L489" target="_blank" rel="noopener" class="_">root metadata file</a>,
which lists the IDs of the root, targets, snapshot, and timestamp public keys.
Clients use these public keys to verify the signatures on all the metadata files
in the repository. This key is held by a collection owner, and should be kept offline
and safe, more so than any other key.</p>
  </li>
  <li>
    <p>The snapshot key signs the
<a href="https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L604" target="_blank" rel="noopener" class="_">snapshot metadata file</a>,
which enumerates the filenames, sizes, and hashes of the root,
targets, and delegation metadata files for the collection. This file is used to
verify the integrity of the other metadata files. The snapshot key is held by
either a collection owner/administrator, or held by the Notary service to facilitate
<a href="/docs.docker.jp.onthefly/notary/advanced_usage/#working-with-delegation-roles">signing by multiple collaborators via delegation roles</a>.</p>
  </li>
  <li>
    <p>The timestamp key signs the
<a href="https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L827" target="_blank" rel="noopener" class="_">timestamp metadata file</a>,
which provides freshness guarantees for the collection by having the shortest expiry time of any particular
piece of metadata and by specifying the filename, size, and hash of the most recent
snapshot for the collection. It is used to verify the integrity of the snapshot
file. The timestamp key is held by the Notary service so the timestamp can be
automatically re-generated when it is requested from the server, rather than
require that a collection owner come online before each timestamp expiry.</p>
  </li>
  <li>
    <p>The targets key signs the
<a href="ttps://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678" target="_blank" rel="noopener" class="_">targets metadata file</a>,
which lists filenames in the collection, and their sizes and respective
<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener" class="_">hashes</a>.
This file is used to verify the integrity of some or all of the actual contents of the repository.
It is also used to
<a href="/docs.docker.jp.onthefly/notary/advanced_usage/#working-with-delegation-roles">delegate trust to other collaborators via delegation roles</a>.
The targets key is held by the collection owner or administrator.</p>
  </li>
  <li>
    <p>Delegation keys sign
<a href="https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L678" target="_blank" rel="noopener" class="_">delegation metadata files</a>,
which lists filenames in the collection, and their sizes and respective
<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener" class="_">hashes</a>.
These files are used to verify the integrity of some or all of the actual contents of the repository.
They are also used to
[delegate trust to other collaborators via lower level <a href="/docs.docker.jp.onthefly/notary/advanced_usage/#work-with-delegation-roles">delegation roles</a>.
Delegation keys are held by anyone from the collection owner or administrator to
collection collaborators.</p>
  </li>
</ul>

<h2 id="architecture-and-components">Architecture and components</h2>

<p>Notary clients pull metadata from one or more (remote) Notary services. Some
Notary clients push metadata to one or more Notary services.</p>

<p>A Notary service consists of a Notary server, which stores and updates the
signed
<a href="https://github.com/theupdateframework/tuf/blob/1bed3e09a478c2c918ffbff10b9118f6e52ee129/docs/tuf-spec.txt#L348" target="_blank" rel="noopener" class="_">TUF metadata files</a>
for multiple trusted collections in an associated database, and a Notary signer, which
stores private keys for and signs metadata for the Notary server. The following
diagram illustrates this architecture:</p>

<p><img src="/notary/images/service-architecture.svg" alt="Notary Service Architecture Diagram" /></p>

<p>Root, targets, and (sometimes) snapshot metadata are generated and signed by
clients, who upload the metadata to the Notary server. The server is
responsible for:</p>

<ul>
  <li>ensuring that any uploaded metadata is valid, signed, and self-consistent</li>
  <li>generating the timestamp (and sometimes snapshot) metadata</li>
  <li>storing and serving to clients the latest valid metadata for any trusted collection</li>
</ul>

<p>The Notary signer is responsible for:</p>

<ul>
  <li>storing the private signing keys
<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-31#section-4.4" target="_blank" rel="noopener" class="_">wrapped</a>
and
<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-31#section-4.8" target="_blank" rel="noopener" class="_">encrypted</a>
using <a href="https://github.com/dvsekhvalnov/jose2go" target="_blank" rel="noopener" class="_">Javascript Object Signing and Encryption</a>
in a database separate from the Notary server database</li>
  <li>performing signing operations with these keys whenever the Notary server requests</li>
</ul>

<h2 id="example-client-server-signer-interaction">Example client-server-signer interaction</h2>

<p>The following diagram illustrates the interactions between the Notary client,
server, and signer:</p>

<p><img src="https://cdn.rawgit.com/docker/notary/27469f01fe244bdf70f34219616657b336724bc3/docs/images/metadata-sequence.svg" alt="Notary Service Sequence Diagram" /></p>

<ol>
  <li>
    <p>Notary server optionally supports authentication from clients using
<a href="https://jwt.io" target="_blank" rel="noopener" class="_">JWT</a> tokens. This requires an
authorization server that manages access controls, and a cert bundle from this
authorization server containing the public key it uses to sign tokens.</p>

    <p>If token authentication is enabled on Notary server, then any connecting
client that does not have a token is redirected to the authorization
server.</p>

    <p>See the docs for
<a href="https://github.com/docker/distribution/blob/master/docs/spec/auth/token.md">Docker Registry v2 authentication</a>
for more information.</p>
  </li>
  <li>
    <p>The client logs in to the authorization server via basic auth over HTTPS,
obtain a bearer token, and then present the token to Notary server on future
requests.</p>
  </li>
  <li>
    <p>When clients uploads new metadata files, Notary server checks them against
any previous versions for conflicts, and verifies the signatures, checksums,
and validity of the uploaded metadata.</p>
  </li>
  <li>
    <p>Once all the uploaded metadata has been validated, Notary server
generates the timestamp (and maybe snapshot) metadata. It sends this
generated metadata to the Notary signer to be signed.</p>
  </li>
  <li>
    <p>Notary signer retrieves the necessary encrypted private keys from its database
if available, decrypts the keys, and uses them to sign the metadata. If
successful, it sends the signatures back to Notary server.</p>
  </li>
  <li>
    <p>Notary server is the source of truth for the state of a trusted collection of
data, storing both client-uploaded and server-generated metadata in the TUF
database. The generated timestamp and snapshot metadata certify that the
metadata files the client uploaded are the most recent for that trusted collection.</p>

    <p>Finally, Notary server notifies the client that their upload was successful.</p>
  </li>
  <li>
    <p>The client can now immediately download the latest metadata from the server,
using the still-valid bearer token to connect. Notary server only needs to
obtain the metadata from the database, since none of the metadata has expired.</p>

    <p>In the case that the timestamp has expired, Notary server would go through
the entire sequence where it generates a new timestamp, request Notary signer
for a signature, stores the newly signed timestamp in the database. It then
sends this new timestamp, along with the rest of the stored metadata, to the
requesting client.</p>
  </li>
</ol>

<h2 id="threat-model">Threat model</h2>

<p>Both the server and the signer are potential attack vectors against all users
of the Notary service. Client keys are also a potential attack vector, but
not necessarily against all collections at a time. This section
discusses how our architecture is designed to deal with compromises.</p>

<h3 id="notary-server-compromise">Notary server compromise</h3>

<p>In the event of a Notary server compromise, an attacker would have direct access to
the metadata stored in the database as well as access to the credentials
used to communicate with Notary signer, and therefore, access to arbitrary signing
operations with any key the Signer holds.</p>

<ul>
  <li>
    <p><strong>Denial of Service</strong> - An attacker could reject client requests and corrupt
or delete metadata from the database, thus preventing clients from the ability
to download or upload metadata.</p>
  </li>
  <li>
    <p><strong>Malicious Content</strong> - An attacker can create, store, and serve arbitrary
metadata content for one or more trusted collections. However, the attacker
has no access to any client-side keys, such as root, targets, and potentially
the snapshot keys for the existing trusted collections.</p>

    <p>A client can only be tricked into downloading and trusting the malicious
content for these trusted collections if it has never seen the trusted
collections and does not have any form of pinned trust.</p>

    <p>If a client has previously interacted with any trusted collection or has its
trust pinned to a specific certificate for the collections, the client
immediately detects that the content is malicious and doesn’t trust any root,
targets, or (maybe) snapshot metadata for these collections.</p>
  </li>
  <li>
    <p><strong>Rollback, Freeze, Mix and Match</strong> - The attacker can request that
the Notary signer sign any arbitrary timestamp (and maybe snapshot) metadata
they want. Attackers can launch a freeze attack, and, depending on whether
the snapshot key is available, a mix-and-match attack up to the expiration
of the targets file.</p>

    <p>Clients both with and without pinned trust would be vulnerable to these
attacks, so long as the attacker ensures that the version number of their
malicious metadata is higher than the version number of the most recent
good metadata that any client may have.</p>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong>: the timestamp and snapshot keys cannot be compromised in a server-only
compromise, so a key rotation would not be necessary. Once the Server
compromise is mitigated, an attacker cannot generate valid timestamp or
snapshot metadata and serve them on a malicious mirror, for example.</p>
</blockquote>

<h3 id="notary-signer-compromise">Notary signer compromise</h3>

<p>In the event of a Notary signer compromise, an attacker would have access to
all the (timestamp and snapshot) private keys stored in a database.
If the keys are stored in an HSM, they would have the ability to sign arbitrary
content with, and to delete, the keys in the HSM, but not to exfiltrate the
private material.</p>

<ul>
  <li>
    <p><strong>Denial of Service</strong> - An attacker could reject all Notary server requests
and corrupt or delete keys from the database (or even delete keys from an
HSM), and thus prevent Notary servers from signing generated
timestamps or snapshots.</p>
  </li>
  <li>
    <p><strong>Key Compromise</strong> - If the Notary signer uses a database as its backend,
an attacker can exfiltrate all the (timestamp and snapshot) private material.
The capabilities of an attacker are the same as of a Notary server
compromise in terms of signing arbitrary metadata, with the important detail
that in this particular case key rotations are necessary to recover from
the attack.</p>
  </li>
</ul>

<h3 id="notary-client-keys-and-credentials-compromise">Notary client keys and credentials compromise</h3>

<p>The security of keys held and administered by users depends on measures taken by
the users. If the Notary Client CLI was used to create them, then they are password
protected and the Notary CLI does not provide options to export them in
plaintext.</p>

<p>It is up to the user to choose an appropriate password, and to protect their key
from offline brute-force attacks.</p>

<p>The severity of the compromise of a trust collection owner/administrator’s
decrypted key depends on the type and combination of keys compromised. For
example, were the snapshot and targets key both compromised, or just the targets
key?</p>

<h4 id="possible-attacks-given-the-credentials-compromised">Possible attacks given the credentials compromised:</h4>

<h5 id="decrypted-delegation-key-only">Decrypted Delegation Key, only</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Delegation key</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
    </tr>
  </tbody>
</table>

<h5 id="decrypted-delegation-key--notary-service-write-capable-credentials">Decrypted Delegation Key + Notary Service write-capable credentials</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Delegation key</td>
      <td>limited, maybe*</td>
      <td>limited, maybe*</td>
      <td>limited, maybe*</td>
    </tr>
  </tbody>
</table>

<p>If the Notary Service holds the snapshot key and the attacker has Notary Service
write credentials, then they have effective access to the snapshot and timestamp
keys because the server generates and signs the snapshot and timestamp for them.</p>

<p>An attacker can add malicious content, remove legitimate content from a collection, and
mix up the targets in a collection, but only within the particular delegation
roles that the key can sign for. Depending on the restrictions on that role,
they may be restricted in what type of content they can modify. They may also
add or remove the capabilities of other delegation keys below it on the key hierarchy
For example, if <code class="language-plaintext highlighter-rouge">DelegationKey2</code> in the above key hierarchy is compromised, the
compromised key could
only modify the capabilities of <code class="language-plaintext highlighter-rouge">DelegationKey4</code> and <code class="language-plaintext highlighter-rouge">DelegationKey5</code>.</p>

<h5 id="decrypted-delegation-key--decrypted-snapshot-key-only">Decrypted Delegation Key + Decrypted Snapshot Key, only</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Delegation key,  Snapshot key</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
    </tr>
  </tbody>
</table>

<p>The attacker does not have access to the timestamp key, which is always held by the Notary
Service, and cannot set up a malicious mirror.</p>

<h5 id="decrypted-delegation-key--decrypted-snapshot-key--notary-service-write-capable-credentials">Decrypted Delegation Key + Decrypted Snapshot Key + Notary Service write-capable credentials</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Delegation key,  Snapshot key</td>
      <td>limited</td>
      <td>limited</td>
      <td>limited</td>
    </tr>
  </tbody>
</table>

<p>The Notary Service always holds the timestamp key. If the attacker has Notary Service
write credentials, then they have effective access to the timestamp key because the server
generates and signs the timestamp for them.</p>

<p>An attacker can add malicious content, remove legitimate content from a collection, and
mix up the targets in a collection, but only within the particular delegation
roles that the key can sign for. Depending on the restrictions on that role,
they may be restricted in what type of content they can modify. A key may also
add or remove the capabilities of other delegation keys below it on the key hierarchy
For example, if <code class="language-plaintext highlighter-rouge">DelegationKey2</code> in the above key hierarchy is compromised, it can
only modify the capabilities of <code class="language-plaintext highlighter-rouge">DelegationKey4</code> and <code class="language-plaintext highlighter-rouge">DelegationKey5</code>.</p>

<h5 id="decrypted-targets-key-only">Decrypted Targets Key, only</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Targets key</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
    </tr>
  </tbody>
</table>

<h5 id="decrypted-targets-key--notary-service-write-capable-credentials">Decrypted Targets Key + Notary Service write-capable credentials</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Targets key</td>
      <td>maybe*</td>
      <td>maybe*</td>
      <td>limited, maybe*</td>
    </tr>
  </tbody>
</table>

<p>If the Notary Service holds the snapshot key and the attacker has Notary Service
write credentials, then they have effective access to the snapshot and timestamp
keys because the server generates and signs the snapshot and timestamp for them.</p>

<p>An attacker can add any malicious content, remove any legitimate content from a
collection, and mix up the targets in a collection. They may also add or remove
the capabilities of any top level delegation key or role, such as <code class="language-plaintext highlighter-rouge">Delegation1</code>,
<code class="language-plaintext highlighter-rouge">Delegation2</code>, and <code class="language-plaintext highlighter-rouge">Delegation3</code> in the key hierarchy diagram. If they remove
the roles entirely, they break the trust chain to the lower delegation roles,
such as <code class="language-plaintext highlighter-rouge">Delegation4</code> or <code class="language-plaintext highlighter-rouge">Delegation5</code>.</p>

<h5 id="decrypted-targets-key--decrypted-snapshot-key-only">Decrypted Targets Key + Decrypted Snapshot Key, only</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Targets key,  Snapshot key</td>
      <td>no</td>
      <td>no</td>
      <td>no</td>
    </tr>
  </tbody>
</table>

<p>The attacker does not have access to the timestamp key, which is always held by the Notary
Service, and cannot set up a malicious mirror.</p>

<h5 id="decrypted-targets-key--decrypted-snapshot-key--notary-service-write-capable-credentials">Decrypted Targets Key + Decrypted Snapshot Key + Notary Service write-capable credentials</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Targets key,  Snapshot key</td>
      <td>yes</td>
      <td>yes</td>
      <td>limited</td>
    </tr>
  </tbody>
</table>

<p>The Notary Service always holds the timestamp key. If the attacker has Notary Service
write credentials, then they have effective access to the timestamp key because the server
generates and signs the timestamp for them.</p>

<p>An attacker can add any malicious content, remove any legitimate content from a
collection, and mix up the targets in a collection. They may also add or remove
the capabilities of any top level delegation key or role, for example, <code class="language-plaintext highlighter-rouge">Delegation1</code>,
<code class="language-plaintext highlighter-rouge">Delegation2</code>, and <code class="language-plaintext highlighter-rouge">Delegation3</code> in the key hierarchy diagram. If they remove
the roles entirely, they’d break the trust chain to the lower delegation roles,
such as <code class="language-plaintext highlighter-rouge">Delegation4</code> or <code class="language-plaintext highlighter-rouge">Delegation5</code>.</p>

<h5 id="decrypted-root-key--none-or-any-combination-of-decrypted-keys-only">Decrypted Root Key + none or any combination of decrypted keys, only</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>All keys</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
    </tr>
  </tbody>
</table>

<p>No other keys are needed, since the attacker can just any rotate or all of them to ones that they
generate. With these keys, they can set up a mirror to serve malicious data - any malicious data
at all, given that they have access to all the keys.</p>

<h5 id="decrypted-root-key--none-or-any-combination-of-decrypted-keys--notary-service-write-capable-credentials">Decrypted Root Key + none or any combination of decrypted keys + Notary Service write-capable credentials</h5>

<table>
  <thead>
    <tr>
      <th>Keys compromised</th>
      <th>Malicious Content</th>
      <th>Rollback, Freeze, Mix and Match</th>
      <th>Denial of Service</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>All keys</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
    </tr>
  </tbody>
</table>

<p>If the Notary Service holds the snapshot key and the attacker has Notary Service
write credentials, then they don’t even need to rotate the snapshot and timestamp
keys because the server generates and signs the snapshot and timestamp for them.</p>

<h4 id="mitigations">Mitigations</h4>

<p>If a root key compromise is detected, the root key holder should contact
whomever runs the notary service to manually reverse any malicious changes to
the repository, and immediately rotate the root key. This creates a fork
of the repository history, and thus break existing clients who have downloaded
any of the malicious changes.</p>

<p>If a targets key compromise is detected, the root key holder
must rotate the compromised key and push a clean set of targets using the new key.</p>

<p>If a delegations key compromise is detected, a higher level key
holder must rotate the compromised key, and push a clean set of targets using the new key.</p>

<p>If a Notary Service credential compromise is detected, the credentials should be
changed immediately.</p>

<h2 id="related-information">Related information</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/notary/running_a_service/">Run a Notary service</a></li>
  <li><a href="/docs.docker.jp.onthefly/notary/reference/">Notary configuration files</a></li>
</ul>
