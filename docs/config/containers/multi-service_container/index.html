
<p>コンテナーの主となる実行プロセスは、<code class="language-plaintext highlighter-rouge">Dockerfile</code> の最終部分に指定される <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> や <code class="language-plaintext highlighter-rouge">CMD</code> です。
1 つのコンテナーには 1 つのサービスを割り当てるということにすれば、気にかける箇所が絞られるので、一般的にはこれが推奨されます。
ただそのサービスからは、複数のプロセスがフォークされることもあります（たとえば Apache ウェブサーバーでは複数のワーカープロセスが起動されます）。
マルチプロセスとなることは、まったく問題ありません。
一方で、アプリケーションが持ついくつもの役割を 1 つのコンテナーに持たせることは、Docker の優れた機能を利用する観点からは避けるべきです。
コンテナーを複数にするのであれば、ユーザー定義のネットワークや共有ボリュームを利用して接続します。</p>

<p>コンテナーのメインプロセスは、コンテナーそのものが起動させるプロセスすべてを管理するためにあります。
メインプロセスが十分に機能していないことが原因で、コンテナー終了時に子プロセスを適切に停止できないことがあります。
起動プロセスがこの手の事態に陥った場合は、コンテナー起動時に <code class="language-plaintext highlighter-rouge">--init</code> オプションを指定してみてください。
この <code class="language-plaintext highlighter-rouge">--init</code> フラグは、コンテナーのメインプロセスとして、非常に小さな初期化プロセスを埋め込みます。
この小さなプロセスが、コンテナー終了時の子プロセス停止を受け持つことになります。
子プロセスの扱いをこのようにするのは、本格的な初期化プロセス、たとえば <code class="language-plaintext highlighter-rouge">sysvinit</code>、<code class="language-plaintext highlighter-rouge">upstart</code>、<code class="language-plaintext highlighter-rouge">systemd</code> に比べて、コンテナー内部のプロセスのライフサイクルを適切に扱うことができるからです。</p>

<p>1 つのコンテナー内に複数のサービスを起動させる必要があるなら、方法はいくつかあります。</p>

<ul>
  <li>
    <p>実行するコマンドをすべてラッパースクリプトに含めます。
あらかじめテストやデバッグは行っておきます。
そしてこのラッパースクリプトを <code class="language-plaintext highlighter-rouge">CMD</code> として実行します。
以下は簡単な例です。
まずはラッパースクリプトを生成します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 1つめのプロセスを起動</span>
./my_first_process <span class="nt">-D</span>
<span class="nv">status</span><span class="o">=</span><span class="nv">$?</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$status</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Failed to start my_first_process: </span><span class="nv">$status</span><span class="s2">"</span>
  <span class="nb">exit</span> <span class="nv">$status</span>
<span class="k">fi</span>

<span class="c"># 2つめのプロセスを起動</span>
./my_second_process <span class="nt">-D</span>
<span class="nv">status</span><span class="o">=</span><span class="nv">$?</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$status</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Failed to start my_second_process: </span><span class="nv">$status</span><span class="s2">"</span>
  <span class="nb">exit</span> <span class="nv">$status</span>
<span class="k">fi</span>

<span class="c"># 単純なチェックとして 1分間隔で2つのプロセスの終了コードを確認します。</span>
<span class="c"># 1つのコンテナーに複数サービスを起動させたい場合に、このような部分が</span>
<span class="c"># 大変なところです。どちらかのプロセスの終了が検出されたら、コンテナー</span>
<span class="c"># はエラー終了するようにします。そうでなければ、60秒ごとに確認しながら</span>
<span class="c"># ループし続けます。</span>

<span class="k">while </span><span class="nb">sleep </span>60<span class="p">;</span> <span class="k">do
  </span>ps aux |grep my_first_process |grep <span class="nt">-q</span> <span class="nt">-v</span> <span class="nb">grep
  </span><span class="nv">PROCESS_1_STATUS</span><span class="o">=</span><span class="nv">$?</span>
  ps aux |grep my_second_process |grep <span class="nt">-q</span> <span class="nt">-v</span> <span class="nb">grep
  </span><span class="nv">PROCESS_2_STATUS</span><span class="o">=</span><span class="nv">$?</span>
  <span class="c"># 上の2つのgrepが検索マッチすれば、どちらの終了ステータスともゼロ。</span>
  <span class="c"># 2つともゼロでないなら何かがおかしい。</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$PROCESS_1_STATUS</span> <span class="nt">-ne</span> 0 <span class="nt">-o</span> <span class="nv">$PROCESS_2_STATUS</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"One of the processes has already exited."</span>
    <span class="nb">exit </span>1
  <span class="k">fi
done</span>
</code></pre></div>    </div>

    <p>Dockerfile は以下のような記述とします。</p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:latest</span>
<span class="k">COPY</span><span class="s"> my_first_process my_first_process</span>
<span class="k">COPY</span><span class="s"> my_second_process my_second_process</span>
<span class="k">COPY</span><span class="s"> my_wrapper_script.sh my_wrapper_script.sh</span>
<span class="k">CMD</span><span class="s"> ./my_wrapper_script.sh</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>1 つのメインプロセスを起動させたら、そのまま起動し続ける場合です。
一時的に別のプロセスをいくつか起動する（そしておそらくはメインプロセスと通信を行う）とします。
この場合は bash のジョブ制御の機能を利用します。
まずはラッパースクリプトを生成します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># ジョブ制御を有効にします。</span>
<span class="nb">set</span> <span class="nt">-m</span>

<span class="c"># 1つめのプロセスをバックグラウンドで実行します。</span>
./my_main_process &amp;

<span class="c"># ヘルパープロセスを実行します。</span>
./my_helper_process

<span class="c"># この my_helper_process は自分の処理を開始して終了するためには、</span>
<span class="c"># 1つめのプロセスの動きを知っておく必要があるかもしれません。</span>


<span class="c"># ここで1つめのプロセスをフォアグラウンド実行に戻してそのままとします。</span>
<span class="nb">fg</span> %1
</code></pre></div>    </div>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:latest</span>
<span class="k">COPY</span><span class="s"> my_main_process my_main_process</span>
<span class="k">COPY</span><span class="s"> my_helper_process my_helper_process</span>
<span class="k">COPY</span><span class="s"> my_wrapper_script.sh my_wrapper_script.sh</span>
<span class="k">CMD</span><span class="s"> ./my_wrapper_script.sh</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">supervisord</code> のようなプロセスマネージャーを利用する場合です。
これは少々面倒な方法です。
これを行うためには、イメージ内に <code class="language-plaintext highlighter-rouge">supervisord</code> パッケージとその設定を含める必要があります。
（あるいは <code class="language-plaintext highlighter-rouge">supervisord</code> が含まれているイメージをベースとします。）
さらにそのパッケージが管理する別のアプリケーションが必要になってきます。
その上で <code class="language-plaintext highlighter-rouge">supervisord</code> を起動させてプロセス管理を行います。
以下はこの手法を利用する Dockerfile です。
<code class="language-plaintext highlighter-rouge">supervisord.conf</code>、<code class="language-plaintext highlighter-rouge">my_first_process</code>、<code class="language-plaintext highlighter-rouge">my_second_process</code> の各ファイルは準備ができていて、Dockerfile と同一ディレクトリに存在しているとします。</p>

    <div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:latest</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> supervisor
<span class="k">RUN </span><span class="nb">mkdir</span> <span class="nt">-p</span> /var/log/supervisor
<span class="k">COPY</span><span class="s"> supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span>
<span class="k">COPY</span><span class="s"> my_first_process my_first_process</span>
<span class="k">COPY</span><span class="s"> my_second_process my_second_process</span>
<span class="k">CMD</span><span class="s"> ["/usr/bin/supervisord"]</span>
</code></pre></div>    </div>
  </li>
</ul>
