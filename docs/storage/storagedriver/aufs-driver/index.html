
<p>AUFS とは <strong>ユニオンファイルシステム</strong>（union filesystem）の一種です。
The <code class="language-plaintext highlighter-rouge">aufs</code> storage driver was previously the default
storage driver used for managing images and layers on Docker for Ubuntu, and for
Debian versions prior to Stretch. If your Linux kernel is version 4.0 or higher,
and you use Docker Engine - Community, consider using the newer
<a href="/docs.docker.jp.onthefly/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener" class="_">overlay2</a>, which has
potential performance advantages over the <code class="language-plaintext highlighter-rouge">aufs</code> storage driver.</p>

<blockquote>
  <p><strong>メモ</strong></p>

  <p>ディストリビューションや Docker エディションの中には AUFS をサポートしていないものがあります。
サポートされているプラットフォームなどの詳しい情報は <a href="#prerequisites">前提条件</a> を参照してください。</p>
</blockquote>

<h2 id="prerequisites">前提条件</h2>

<ul>
  <li>For Docker Engine - Community, AUFS is supported on Ubuntu, and on Debian versions prior to
Stretch.</li>
  <li>For Docker EE, AUFS is supported on Ubuntu.</li>
  <li>If you use Ubuntu, you need to add the AUFS module to the kernel. If you do
not install these packages, you need to use  <code class="language-plaintext highlighter-rouge">overlay2</code>.</li>
  <li>AUFS cannot use the following backing filesystems: <code class="language-plaintext highlighter-rouge">aufs</code>, <code class="language-plaintext highlighter-rouge">btrfs</code>, or
<code class="language-plaintext highlighter-rouge">ecryptfs</code>. This means that the filesystem which contains
<code class="language-plaintext highlighter-rouge">/var/lib/docker/aufs</code> cannot be one of these filesystem types.</li>
</ul>

<h2 id="configure-docker-with-the-aufs-storage-driver"><code class="language-plaintext highlighter-rouge">aufs</code> ストレージドライバーの設定</h2>

<p>Docker の起動時に AUFS ドライバーがカーネルにロードされていて、その他のス。トレージドライバーの設定がされていなければ、Docker はデフォルトでこの AUFS ドライバーを利用します。</p>

<ol>
  <li>
    <p>以下のコマンドを実行して、利用するカーネルが AUFS に対応していることを確認します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep </span>aufs /proc/filesystems

nodev   aufs
</code></pre></div>    </div>
  </li>
  <li>
    <p>Docker がどのストレージドライバーを利用しているかを確認します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker info

&lt;truncated output&gt;
Storage Driver: aufs
 Root Dir: /var/lib/docker/aufs
 Backing Filesystem: extfs
 Dirs: 0
 Dirperm1 Supported: <span class="nb">true</span>
&lt;truncated output&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>If you are using a different storage driver, either AUFS is not included in
the kernel (in which case a different default driver is used) or that
Docker has been explicitly configured to use a different driver. Check
<code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code> or the output of <code class="language-plaintext highlighter-rouge">ps auxw | grep dockerd</code> to see
if Docker has been started with the <code class="language-plaintext highlighter-rouge">--storage-driver</code> flag.</p>
  </li>
</ol>

<h2 id="how-the-aufs-storage-driver-works"><code class="language-plaintext highlighter-rouge">aufs</code> ストレージドライバーはどのように動作するか</h2>

<p>AUFS is a <em>union filesystem</em>, which means that it layers multiple directories on
a single Linux host and presents them as a single directory. These directories
are called <em>branches</em> in AUFS terminology, and <em>layers</em> in Docker terminology.</p>

<p>The unification process is referred to as a <em>union mount</em>.</p>

<p>The diagram below shows a Docker container based on the <code class="language-plaintext highlighter-rouge">ubuntu:latest</code> image.</p>

<p><img src="/docs.docker.jp.onthefly/storage/storagedriver/images/aufs_layers.jpg" alt="Ubuntu コンテナーのレイヤー" /></p>

<p>Each image layer, and the container layer, are represented on the Docker host as
subdirectories within <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>. The union mount provides the unified
view of all layers. The directory names do not directly correspond to the IDs
of the layers themselves.</p>

<p>AUFS uses the Copy-on-Write (CoW) strategy to maximize storage efficiency and
minimize overhead.</p>

<h3 id="example-image-and-container-on-disk-constructs">イメージとコンテナーのディスク上の構成例</h3>

<p>The following <code class="language-plaintext highlighter-rouge">docker pull</code> command shows a Docker host downloading a Docker
image comprising five layers.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker pull ubuntu

Using default tag: latest
latest: Pulling from library/ubuntu
b6f892c0043b: Pull <span class="nb">complete
</span>55010f332b04: Pull <span class="nb">complete
</span>2955fb827c94: Pull <span class="nb">complete
</span>3deef3fcbd30: Pull <span class="nb">complete
</span>cf9722e506aa: Pull <span class="nb">complete
</span>Digest: sha256:382452f82a8bbd34443b2c727650af46aced0f94a44463c62a9848133ecb1aa8
Status: Downloaded newer image <span class="k">for </span>ubuntu:latest
</code></pre></div></div>

<h4 id="the-image-layers">イメージレイヤー</h4>

<blockquote>
  <p><strong>Warning</strong>: Do not directly manipulate any files or directories within
<code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>. These files and directories are managed by Docker.</p>
</blockquote>

<p>All of the information about the image and container layers is stored in
subdirectories of <code class="language-plaintext highlighter-rouge">/var/lib/docker/aufs/</code>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">diff/</code>: the <strong>contents</strong> of each layer, each stored in a separate
subdirectory</li>
  <li><code class="language-plaintext highlighter-rouge">layers/</code>: metadata about how image layers are stacked. This directory
contains one file for each image or container layer on the Docker host. Each
file contains the IDs of all the layers below it in the stack (its parents).</li>
  <li><code class="language-plaintext highlighter-rouge">mnt/</code>: Mount points, one per image or container layer, which are used to
assemble and mount the unified filesystem for a container. For images, which
are read-only, these directories are always empty.</li>
</ul>

<h4 id="the-container-layer">The container layer</h4>

<p>If a container is running, the contents of <code class="language-plaintext highlighter-rouge">/var/lib/docker/aufs/</code> change in the
following ways:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">diff/</code>: Differences introduced in the writable container layer, such as new
 or modified files.</li>
  <li><code class="language-plaintext highlighter-rouge">layers/</code>: Metadata about the writable container layer’s parent layers.</li>
  <li><code class="language-plaintext highlighter-rouge">mnt/</code>: A mount point for each running container’s unified filesystem, exactly
as it appears from within the container.</li>
</ul>

<h2 id="how-container-reads-and-writes-work-with-aufs">How container reads and writes work with <code class="language-plaintext highlighter-rouge">aufs</code></h2>

<h3 id="reading-files">Reading files</h3>

<p>Consider three scenarios where a container opens a file for read access with
aufs.</p>

<ul>
  <li>
    <p><strong>The file does not exist in the container layer</strong>: If a container opens a
file for read access and the file does not already exist in the container
layer, the storage driver searches for the file in the image layers,
starting with the layer just below the container layer. It is read from the
layer where it is found.</p>
  </li>
  <li>
    <p><strong>The file only exists in the container layer</strong>: If a container opens a file
for read access and the file exists in the container layer, it is read from
there.</p>
  </li>
  <li>
    <p><strong>The file exists in both the container layer and the image layer</strong>: If a
container opens a file for read access and the file exists in the container
layer and one or more image layers, the file is read from the container layer.
Files in the container layer obscure files with the same name in the image
layers.</p>
  </li>
</ul>

<h3 id="modifying-files-or-directories">Modifying files or directories</h3>

<p>Consider some scenarios where files in a container are modified.</p>

<ul>
  <li>
    <p><strong>Writing to a file for the first time</strong>: The first time a container writes
to an existing file, that file does not exist in the container (<code class="language-plaintext highlighter-rouge">upperdir</code>).
The <code class="language-plaintext highlighter-rouge">aufs</code> driver performs a <em>copy_up</em> operation to copy the file from the
image layer where it exists to the writable container layer. The container
then writes the changes to the new copy of the file in the container layer.</p>

    <p>However, AUFS works at the file level rather than the block level. This
means that all copy_up operations copy the entire file, even if the file is
very large and only a small part of it is being modified. This can have a
noticeable impact on container write performance. AUFS can suffer
noticeable latencies when searching for files in images with many layers.
However, it is worth noting that the copy_up operation only occurs the first
time a given file is written to. Subsequent writes to the same file operate
against the copy of the file already copied up to the container.</p>
  </li>
  <li>
    <p><strong>Deleting files and directories</strong>:</p>

    <ul>
      <li>
        <p>When a <em>file</em> is deleted within a container, a <em>whiteout</em> file is created
in the container layer. The version of the file in the image layer is not
deleted (because the image layers are read-only). However, the whiteout
file prevents it from being available to the container.</p>
      </li>
      <li>
        <p>When a <em>directory</em> is deleted within a container, an <em>opaque file</em> is
created in the container layer. This works in the same way as a
whiteout file and effectively prevents the directory from being accessed,
even though it still exists in the image layer.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Renaming directories</strong>: Calling <code class="language-plaintext highlighter-rouge">rename(2)</code> for a directory is not fully
supported on AUFS. It returns <code class="language-plaintext highlighter-rouge">EXDEV</code> (“cross-device link not permitted”),
even when both of the source and the destination path are on a same AUFS
layer, unless the directory has no children. Your application needs to be
designed to handle <code class="language-plaintext highlighter-rouge">EXDEV</code> and fall back to a “copy and unlink” strategy.</p>
  </li>
</ul>

<h2 id="aufs-and-docker-performance">AUFS and Docker performance</h2>

<p>To summarize some of the performance related aspects already mentioned:</p>

<ul>
  <li>
    <p>The AUFS storage driver is less performant than the <code class="language-plaintext highlighter-rouge">overlay2</code> driver, but is
a good choice for PaaS and other similar use-cases where container density is
important. This is because AUFS efficiently shares images between multiple
running containers, enabling fast container start times and minimal use of
disk space.</p>
  </li>
  <li>
    <p>The underlying mechanics of how AUFS shares files between image layers and
containers uses the page cache very efficiently.</p>
  </li>
  <li>
    <p>The AUFS storage driver can introduce significant latencies into container
write performance. This is because the first time a container writes to any
file, the file needs to be located and copied into the containers top writable
layer. These latencies increase and are compounded when these files exist below
many image layers and the files themselves are large.</p>
  </li>
</ul>

<h3 id="performance-best-practices">Performance best practices</h3>

<p>The following generic performance best practices also apply to AUFS.</p>

<ul>
  <li>
    <p><strong>Solid State Devices (SSD)</strong> provide faster reads and writes than spinning
disks.</p>
  </li>
  <li>
    <p><strong>Use volumes for write-heavy workloads</strong>: Volumes provide the best and most
predictable performance for write-heavy workloads. This is because they bypass
the storage driver and do not incur any of the potential overheads introduced
by thin provisioning and copy-on-write. Volumes have other benefits, such as
allowing you to share data among containers and persisting even when no
running container is using them.</p>
  </li>
</ul>

<h2 id="related-information">関連情報</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/storage/volumes/">Volumes</a></li>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/">Understand images, containers, and storage drivers</a></li>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/select-storage-driver/">Select a storage driver</a></li>
</ul>
