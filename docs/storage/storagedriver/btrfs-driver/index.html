<p>Btrfs is a next generation copy-on-write filesystem that supports many advanced
storage technologies that make it a good fit for Docker. Btrfs is included in
the mainline Linux kernel.</p>

<p>Docker’s <code class="language-plaintext highlighter-rouge">btrfs</code> storage driver leverages many Btrfs features for image and
container management. Among these features are block-level operations, thin
provisioning, copy-on-write snapshots, and ease of administration. You can
easily combine multiple physical block devices into a single Btrfs filesystem.</p>

<p>This article refers to Docker’s Btrfs storage driver as <code class="language-plaintext highlighter-rouge">btrfs</code> and the overall
Btrfs Filesystem as Btrfs.</p>

<blockquote>
  <p><strong>Note</strong>: The <code class="language-plaintext highlighter-rouge">btrfs</code> storage driver is only supported on Docker Engine - Community on Ubuntu or Debian.</p>
</blockquote>

<h2 id="prerequisites">Prerequisites</h2>

<p><code class="language-plaintext highlighter-rouge">btrfs</code> is supported if you meet the following prerequisites:</p>

<ul>
  <li>
    <p><strong>Docker Engine - Community</strong>: For Docker Engine - Community, <code class="language-plaintext highlighter-rouge">btrfs</code> is only recommended on Ubuntu or Debian.</p>
  </li>
  <li>
    <p>Changing the storage driver makes any containers you have already
created inaccessible on the local system. Use <code class="language-plaintext highlighter-rouge">docker save</code> to save containers,
and push existing images to Docker Hub or a private repository, so that you
not need to re-create them later.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">btrfs</code> requires a dedicated block storage device such as a physical disk. This
block device must be formatted for Btrfs and mounted into <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>.
The configuration instructions below walk you through this procedure. By
default, the SLES <code class="language-plaintext highlighter-rouge">/</code> filesystem is formatted with BTRFS, so for SLES, you do
not need to use a separate block device, but you can choose to do so for
performance reasons.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">btrfs</code> support must exist in your kernel. To check this, run the following
command:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">grep </span>btrfs /proc/filesystems

btrfs
</code></pre></div>    </div>
  </li>
  <li>
    <p>To manage BTRFS filesystems at the level of the operating system, you need the
<code class="language-plaintext highlighter-rouge">btrfs</code> command. If you do not have this command, install the <code class="language-plaintext highlighter-rouge">btrfsprogs</code>
package (SLES) or <code class="language-plaintext highlighter-rouge">btrfs-tools</code> package (Ubuntu).</p>
  </li>
</ul>

<h2 id="configure-docker-to-use-the-btrfs-storage-driver">Configure Docker to use the btrfs storage driver</h2>

<p>This procedure is essentially identical on SLES and Ubuntu.</p>

<ol>
  <li>
    <p>Stop Docker.</p>
  </li>
  <li>
    <p>Copy the contents of <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code> to a backup location, then empty
the contents of <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo cp</span> <span class="nt">-au</span> /var/lib/docker /var/lib/docker.bk
<span class="nv">$ </span><span class="nb">sudo rm</span> <span class="nt">-rf</span> /var/lib/docker/<span class="k">*</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Format your dedicated block device or devices as a Btrfs filesystem. This
example assumes that you are using two block devices called <code class="language-plaintext highlighter-rouge">/dev/xvdf</code> and
<code class="language-plaintext highlighter-rouge">/dev/xvdg</code>. Double-check the block device names because this is a
destructive operation.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>mkfs.btrfs <span class="nt">-f</span> /dev/xvdf /dev/xvdg
</code></pre></div>    </div>

    <p>There are many more options for Btrfs, including striping and RAID. See the
<a href="https://btrfs.wiki.kernel.org/index.php/Using_Btrfs_with_Multiple_Devices">Btrfs documentation</a>.</p>
  </li>
  <li>
    <p>Mount the new Btrfs filesystem on the <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code> mount point. You
can specify any of the block devices used to create the Btrfs filesystem.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>mount <span class="nt">-t</span> btrfs /dev/xvdf /var/lib/docker
</code></pre></div>    </div>

    <p>Don’t forget to make the change permanent across reboots by adding an
entry to <code class="language-plaintext highlighter-rouge">/etc/fstab</code>.</p>
  </li>
  <li>
    <p>Copy the contents of <code class="language-plaintext highlighter-rouge">/var/lib/docker.bk</code> to <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo cp</span> <span class="nt">-au</span> /var/lib/docker.bk/<span class="k">*</span> /var/lib/docker/
</code></pre></div>    </div>
  </li>
  <li>
    <p>Configure Docker to use the <code class="language-plaintext highlighter-rouge">btrfs</code> storage driver. This is required even
though <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code> is now using a Btrfs filesystem.
Edit or create the file <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code>. If it is a new file, add
the following contents. If it is an existing file, add the key and value
only, being careful to end the line with a comma if it is not the final
line before an ending curly bracket (<code class="language-plaintext highlighter-rouge">}</code>).</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"storage-driver"</span><span class="p">:</span><span class="w"> </span><span class="s2">"btrfs"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>

    <p>See all storage options for each storage driver in the
<a href="/engine/reference/commandline/dockerd/#storage-driver-options">daemon reference documentation</a></p>
  </li>
  <li>
    <p>Start Docker. After it is running, verify that <code class="language-plaintext highlighter-rouge">btrfs</code> is being used as the
storage driver.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker info

Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 17.03.1-ce
Storage Driver: btrfs
 Build Version: Btrfs v4.4
 Library Version: 101
&lt;output truncated&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>When you are ready, remove the <code class="language-plaintext highlighter-rouge">/var/lib/docker.bk</code> directory.</p>
  </li>
</ol>

<h2 id="manage-a-btrfs-volume">Manage a Btrfs volume</h2>

<p>One of the benefits of Btrfs is the ease of managing Btrfs filesystems without
the need to unmount the filesystem or restart Docker.</p>

<p>When space gets low, Btrfs automatically expands the volume in <em>chunks</em> of
roughly 1 GB.</p>

<p>To add a block device to a Btrfs volume, use the <code class="language-plaintext highlighter-rouge">btrfs device add</code> and
<code class="language-plaintext highlighter-rouge">btrfs filesystem balance</code> commands.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>btrfs device add /dev/svdh /var/lib/docker

<span class="nv">$ </span><span class="nb">sudo </span>btrfs filesystem balance /var/lib/docker
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong>: While you can do these operations with Docker running, performance
suffers. It might be best to plan an outage window to balance the Btrfs
filesystem.</p>
</blockquote>

<h2 id="how-the-btrfs-storage-driver-works">How the <code class="language-plaintext highlighter-rouge">btrfs</code> storage driver works</h2>

<p>The <code class="language-plaintext highlighter-rouge">btrfs</code> storage driver works differently from <code class="language-plaintext highlighter-rouge">devicemapper</code> or other
storage drivers in that your entire <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code> directory is stored on a
Btrfs volume.</p>

<h3 id="image-and-container-layers-on-disk">Image and container layers on-disk</h3>

<p>Information about image layers and writable container layers is stored in
<code class="language-plaintext highlighter-rouge">/var/lib/docker/btrfs/subvolumes/</code>. This subdirectory contains one directory
per image or container layer, with the unified filesystem built from a layer
plus all its parent layers. Subvolumes are natively copy-on-write and have space
allocated to them on-demand from an underlying storage pool. They can also be
nested and snapshotted. The diagram below shows 4 subvolumes. ‘Subvolume 2’ and
‘Subvolume 3’ are nested, whereas ‘Subvolume 4’ shows its own internal directory
tree.</p>

<p><img src="/docs.docker.jp.onthefly/storage/storagedriver/images/btfs_subvolume.jpg" alt="subvolume example" /></p>

<p>Only the base layer of an image is stored as a true subvolume. All the other
layers are stored as snapshots, which only contain the differences introduced
in that layer. You can create snapshots of snapshots as shown in the diagram
below.</p>

<p><img src="/docs.docker.jp.onthefly/storage/storagedriver/images/btfs_snapshots.jpg" alt="snapshots diagram" /></p>

<p>On disk, snapshots look and feel just like subvolumes, but in reality they are
much smaller and more space-efficient. Copy-on-write is used to maximize storage
efficiency and minimize layer size, and writes in the container’s writable layer
are managed at the block level. The following image shows a subvolume and its
snapshot sharing data.</p>

<p><img src="/docs.docker.jp.onthefly/storage/storagedriver/images/btfs_pool.jpg" alt="snapshot and subvolume sharing data" /></p>

<p>For maximum efficiency, when a container needs more space, it is allocated in
<em>chunks</em> of roughly 1 GB in size.</p>

<p>Docker’s <code class="language-plaintext highlighter-rouge">btrfs</code> storage driver stores every image layer and container in its
own Btrfs subvolume or snapshot. The base layer of an image is stored as a
subvolume whereas child image layers and containers are stored as snapshots.
This is shown in the diagram below.</p>

<p><img src="/docs.docker.jp.onthefly/storage/storagedriver/images/btfs_container_layer.jpg" alt="Btrfs container layers" /></p>

<p>The high level process for creating images and containers on Docker hosts
running the <code class="language-plaintext highlighter-rouge">btrfs</code> driver is as follows:</p>

<ol>
  <li>
    <p>The image’s base layer is stored in a Btrfs <em>subvolume</em> under
<code class="language-plaintext highlighter-rouge">/var/lib/docker/btrfs/subvolumes</code>.</p>
  </li>
  <li>
    <p>Subsequent image layers are stored as a Btrfs <em>snapshot</em> of the parent
layer’s subvolume or snapshot, but with the changes introduced by this
layer. These differences are stored at the block level.</p>
  </li>
  <li>
    <p>The container’s writable layer is a Btrfs snapshot of the final image layer,
with the differences introduced by the running container. These differences
are stored at the block level.</p>
  </li>
</ol>

<h2 id="how-container-reads-and-writes-work-with-btrfs">How container reads and writes work with <code class="language-plaintext highlighter-rouge">btrfs</code></h2>

<h3 id="reading-files">Reading files</h3>

<p>A container is a space-efficient snapshot of an image. Metadata in the snapshot
points to the actual data blocks in the storage pool. This is the same as with
a subvolume. Therefore, reads performed against a snapshot are essentially the
same as reads performed against a subvolume.</p>

<h3 id="writing-files">Writing files</h3>

<ul>
  <li>
    <p><strong>Writing new files</strong>: Writing a new file to a container invokes an allocate-on-demand
operation to allocate new data block to the container’s snapshot. The file is
then written to this new space. The allocate-on-demand operation is native to
all writes with Btrfs and is the same as writing new data to a subvolume. As a
result, writing new files to a container’s snapshot operates at native Btrfs
speeds.</p>
  </li>
  <li>
    <p><strong>Modifying existing files</strong>: Updating an existing file in a container is a copy-on-write
operation (<em>redirect-on-write</em> is the Btrfs terminology). The original data is
read from the layer where the file currently exists, and only the modified
blocks are written into the container’s writable layer. Next, the Btrfs driver
updates the filesystem metadata in the snapshot to point to this new data.
This behavior incurs very little overhead.</p>
  </li>
  <li>
    <p><strong>Deleting files or directories</strong>: If a container deletes a file or directory
that exists in a lower layer, Btrfs masks the existence of the file or
directory in the lower layer. If a container creates a file and then deletes
it, this operation is performed in the Btrfs filesystem itself and the space
is reclaimed.</p>
  </li>
</ul>

<p>With Btrfs, writing and updating lots of small files can result in slow
performance.</p>

<h2 id="btrfs-and-docker-performance">Btrfs and Docker performance</h2>

<p>There are several factors that influence Docker’s performance under the <code class="language-plaintext highlighter-rouge">btrfs</code>
storage driver.</p>

<blockquote>
  <p><strong>Note</strong>: Many of these factors are mitigated by using Docker volumes for
write-heavy workloads, rather than relying on storing data in the container’s
writable layer. However, in the case of Btrfs, Docker volumes still suffer
from these draw-backs unless <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/</code> is <strong>not</strong> backed by
Btrfs.</p>
</blockquote>

<ul>
  <li>
    <p><strong>Page caching</strong>. Btrfs does not support page cache sharing. This means that
each process accessing the same file copies the file into the Docker hosts’s
memory. As a result, the <code class="language-plaintext highlighter-rouge">btrfs</code> driver may not be the best choice
high-density use cases such as PaaS.</p>
  </li>
  <li>
    <p><strong>Small writes</strong>. Containers performing lots of small writes (this usage
pattern matches what happens when you start and stop many containers in a short
period of time, as well) can lead to poor use of Btrfs chunks. This can
prematurely fill the Btrfs filesystem and lead to out-of-space conditions on
your Docker host. Use <code class="language-plaintext highlighter-rouge">btrfs filesys show</code> to closely monitor the amount of
free space on your Btrfs device.</p>
  </li>
  <li>
    <p><strong>Sequential writes</strong>. Btrfs uses a journaling technique when writing to disk.
This can impact the performance of sequential writes, reducing performance by
up to 50%.</p>
  </li>
  <li>
    <p><strong>Fragmentation</strong>. Fragmentation is a natural byproduct of copy-on-write
filesystems like Btrfs. Many small random writes can compound this issue.
Fragmentation can manifest as CPU spikes when using SSDs or head thrashing
when using spinning disks. Either of these issues can harm performance.</p>

    <p>If your Linux kernel version is 3.9 or higher, you can enable the <code class="language-plaintext highlighter-rouge">autodefrag</code>
feature when mounting a Btrfs volume. Test this feature on your own workloads
before deploying it into production, as some tests have shown a negative
impact on performance.</p>
  </li>
  <li>
    <p><strong>SSD performance</strong>: Btrfs includes native optimizations for SSD media.
To enable these features, mount the Btrfs filesystem with the <code class="language-plaintext highlighter-rouge">-o ssd</code> mount
option. These optimizations include enhanced SSD write performance by avoiding
optimization such as <em>seek optimizations</em> which do not apply to solid-state
media.</p>
  </li>
  <li>
    <p><strong>Balance Btrfs filesystems often</strong>: Use operating system utilities such as a
<code class="language-plaintext highlighter-rouge">cron</code> job to balance the Btrfs filesystem regularly, during non-peak hours.
This reclaims unallocated blocks and helps to prevent the filesystem from
filling up unnecessarily. You cannot rebalance a totally full Btrfs
filesystem unless you add additional physical block devices to the filesystem.
See the
<a href="https://btrfs.wiki.kernel.org/index.php/Balance_Filters#Balancing_to_fix_filesystem_full_errors">BTRFS Wiki</a>.</p>
  </li>
  <li>
    <p><strong>Use fast storage</strong>: Solid-state drives (SSDs) provide faster reads and
writes than spinning disks.</p>
  </li>
  <li>
    <p><strong>Use volumes for write-heavy workloads</strong>: Volumes provide the best and most
predictable performance for write-heavy workloads. This is because they bypass
the storage driver and do not incur any of the potential overheads introduced
by thin provisioning and copy-on-write. Volumes have other benefits, such as
allowing you to share data among containers and persisting even when no
running container is using them.</p>
  </li>
</ul>

<h2 id="related-information">Related Information</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/storage/volumes/">Volumes</a></li>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/">Understand images, containers, and storage drivers</a></li>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/select-storage-driver/">Select a storage driver</a></li>
</ul>
