
<p>ストレージドライバーを効率よく利用するためには、Docker がどのようにしてイメージをビルドし保存するのか、またそのイメージをコンテナーがどのように利用するのかを理解しておくことが重要です。
これがわかっていれば、その知識に基づいた判断として、アプリケーションデータの適切な保存方法や、アプリケーション稼動中のパフォーマンス問題に対して、最良の方策をとることができます。</p>

<p>ストレージドライバーは、コンテナー内の書き込み可能なレイヤーにデータを保存するものです。
これがファイルデータであると、コンテナーが削除された後にデータは維持されず、通常のファイルシステム上でのパフォーマンスに比べて、読み書きの速度は低下します。</p>

<blockquote>
  <p><strong>メモ</strong>: 問題が発生すると言われる処理として、書き込みを重点的に行うデータベースストレージの利用があります。
特に読み込み専用レイヤーに既にデータが存在している場合が挙げられます。
詳しくは本文にて説明します。</p>
</blockquote>

<p><a href="/docs.docker.jp.onthefly/storage/volumes/">ボリューム利用方法について学ぶ</a> を参照してデータ保存方法やパフォーマンス改善について確認してください。</p>

<h2 id="images-and-layers">イメージとレイヤー</h2>

<p>Docker イメージは一連のレイヤーから構成されます。
個々のレイヤーは、そのイメージの Dockerfile 内にある 1 つの命令に対応づいています。
一番最後にあるレイヤーを除き、これ以外はすべて読み込み専用のレイヤーです。
たとえば以下のような Dockerfile を考えてみます。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:18.04</span>
<span class="k">COPY</span><span class="s"> . /app</span>
<span class="k">RUN </span>make /app
<span class="k">CMD</span><span class="s"> python /app/app.py</span>
</code></pre></div></div>

<p>この Dockerfile には 4 つのコマンドがあります。
コマンドのそれぞれが 1 つのレイヤーを生成します。
まずは <code class="language-plaintext highlighter-rouge">FROM</code> 命令によって <code class="language-plaintext highlighter-rouge">ubuntu:18.04</code> イメージから 1 つのレイヤーが生成されるところから始まります。
<code class="language-plaintext highlighter-rouge">COPY</code> 命令は Docker クライアントのカレントディレクトリから複数のファイルを追加します。
<code class="language-plaintext highlighter-rouge">RUN</code> 命令は <code class="language-plaintext highlighter-rouge">make</code> コマンドを実行してアプリケーションをビルドします。
そして最後のレイヤーが、コンテナー内にて実行するべきコマンドを指定しています。</p>

<p>各レイヤーは、その直前のレイヤーからの差異だけを保持します。
そしてレイヤーは順に積み上げられていきます。
新しいコンテナーを生成したときには、それまで存在していたレイヤー群の最上部に、新たな書き込み可能なレイヤーが加えられます。
このレイヤーは「コンテナーレイヤー」と呼ばれることがあります。
実行中のコンテナーに対して実行される変更処理すべて、たとえば新規ファイル生成、既存ファイル修正、ファイル削除といったことは、その薄い皮のような書き込み可能なコンテナーレイヤーに対して書き込まれます。
以下の図は Ubuntu 15.04 イメージに基づいて生成されたコンテナーを表わしています。</p>

<p><img src="/docs.docker.jp.onthefly/storage/storagedriver/images/container-layers.jpg" alt="Ubuntu イメージに基づくコンテナーのレイヤー" /></p>

<p><strong>ストレージドライバー</strong> というものは、そういった各レイヤーが互いにやり取りできるようにします。
さまざまなストレージドライバーが利用可能であり、利用状況に応じて一長一短があります。</p>

<h2 id="container-and-layers">コンテナーとレイヤー</h2>

<p>コンテナーとイメージの大きな違いは、最上部に書き込みレイヤーがあるかどうかです。
コンテナーに対して新たに加えられたり修正されたりしたデータは、すべてこの書き込みレイヤーに保存されます。
コンテナーが削除されると、その書き込みレイヤーも同じく削除されます。
ただしその元にあったイメージは、変更されずに残ります。</p>

<p>複数のコンテナーを見た場合、そのコンテナーごとに個々の書き込み可能なコンテナーレイヤーがあって、データ更新結果はそのコンテナーレイヤーに保存されます。
したがって複数コンテナーでは、同一のイメージを共有しながらアクセスすることができ、しかも個々に見れば独自の状態を持つことができることになります。
以下の図は、Ubuntu 15.04 という同一のイメージを共有する複数コンテナーを示しています。</p>

<p><img src="/docs.docker.jp.onthefly/storage/storagedriver/images/sharing-layers.jpg" alt="同一のイメージを共有する複数コンテナー" /></p>

<blockquote>
  <p><strong>メモ</strong>: 複数イメージを必要としていて、さらに同一のデータを共有してアクセスしたい場合は、そのデータを Docker ボリュームに保存して、コンテナー内でそれをマウントします。</p>
</blockquote>

<p>Docker はストレージドライバーを利用して、イメージレイヤーと書き込み可能なコンテナーレイヤーの各内容を管理します。
さまざまなストレージドライバーでは、異なる実装によりデータを扱います。
しかしどのようなドライバーであっても、積み上げ可能な（stackable）イメージレイヤーを取り扱い、コピーオンライト（copy-on-write; CoW）方式を採用します。</p>

<h2 id="container-size-on-disk">ディスク上のコンテナーサイズ</h2>

<p>稼働中コンテナーの概算サイズを確認するには <code class="language-plaintext highlighter-rouge">docker ps -s</code> コマンドを実行します。
サイズに関連した 2 つのデータがカラム表示されます。</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">size</code>: （ディスク上の）データ総量。
各コンテナーの書き込みレイヤーが利用するデータ部分です。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">virtual size</code>: コンテナーにおいて利用されている読み込み専用のイメージデータと、コンテナーの書き込みレイヤーの <code class="language-plaintext highlighter-rouge">size</code> を足し合わせたデータ総量。
複数コンテナーにおいては、読み込み専用イメージデータの全部または一部を共有しているかもしれません。
1 つのイメージをベースとして作った 2 つのコンテナーでは、読み込み専用データを 100% 共有します。
一方で 2 つの異なるイメージが一部に共通するレイヤーを持っていて、そこからそれぞれに 2 つのコンテナーを作ったとすると、共有するのはその共通レイヤー部分のみです。
したがって <code class="language-plaintext highlighter-rouge">virtual size</code> は単純に足し合わせで計算できるものではありません。
これはディスク総量を多く見積もってしまい、その量は無視できないほどになることがあります。</p>
  </li>
</ul>

<p>起動しているコンテナーすべてが利用するディスク総量は、各コンテナーの <code class="language-plaintext highlighter-rouge">size</code> と <code class="language-plaintext highlighter-rouge">virtual size</code> を適宜組み合わせた値になります。
1 つのイメージだけに基づいた複数コンテナーの場合、そのディスク総量は、すべての <code class="language-plaintext highlighter-rouge">size</code> の合計に 1 つのイメージサイズ（<code class="language-plaintext highlighter-rouge">virtual size</code>- <code class="language-plaintext highlighter-rouge">size</code>）を加えて得られます。</p>

<p>またコンテナーがディスク領域を消費するものであっても、以下に示す状況はディスク総量の算定には含まれません。</p>

<ul>
  <li>ロギングドライバー <code class="language-plaintext highlighter-rouge">json-file</code> を利用している場合に、そのログファイルが利用するディスク量。
コンテナーにおいてログ出力を大量に行っていて、ログローテーションを用いていない場合には、このディスク量は無視できないものになります。</li>
  <li>コンテナーが利用するボリュームやバインドマウント。</li>
  <li>コンテナーの設定ファイルが利用するディスク領域。
そのデータ容量は少ないのが普通です。</li>
  <li>（スワップが有効である場合に）ディスクに書き込まれるメモリデータ。</li>
  <li>試験的な checkpoint/restore 機能を利用している場合のチェックポイント。</li>
</ul>

<h2 id="the-copy-on-write-cow-strategy">コピーオンライト方式</h2>

<p>コピーオンライト（copy-on-write; CoW）は、ファイルの共有とコピーを最も効率よく行う方式です。
イメージ内の下の方にあるレイヤーに、ファイルやディレクトリが存在していた場合に、別のレイヤー（書き込みレイヤーを含む）からの読み込みアクセスが必要であるとします。
このときには、当然のことながら存在しているそのファイルを利用します。
そのファイルを修正する必要のある別のレイヤーがあったとすると、これを初めて修正するとき（イメージがビルドされたときやコンテナーが起動したときなど）、そのファイルはレイヤーにコピーされた上で修正されます。
こうすることで入出力を最小限に抑え、次に続くレイヤーの各サイズも増やさずに済みます。
この利点に関しては、さらに詳しく後述します。</p>

<h3 id="sharing-promotes-smaller-images">共有によりイメージサイズはより小さく</h3>

<p><code class="language-plaintext highlighter-rouge">docker pull</code> を実行してリポジトリからイメージをプルするとき、あるいはイメージから新たにコンテナーを生成するにあたってそのイメージがまだローカルに生成されていないとき、各レイヤーはプルによって個別に取得されて、Docker のローカル保存領域、たとえば Linux では通常 <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code> に保存されます。
取得された各レイヤーは、以下の例のようにして確認することができます。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker pull ubuntu:18.04
18.04: Pulling from library/ubuntu
f476d66f5408: Pull <span class="nb">complete
</span>8882c27f669e: Pull <span class="nb">complete
</span>d9af21273955: Pull <span class="nb">complete
</span>f5029279ec12: Pull <span class="nb">complete
</span>Digest: sha256:ab6cb8de3ad7bb33e2534677f865008535427390b117d7939193f8d1a6613e34
Status: Downloaded newer image <span class="k">for </span>ubuntu:18.04
</code></pre></div></div>

<p>各レイヤーは、Docker ホストのローカル保存領域内にて、それぞれのディレクトリ配下に保存されます。
ファイルシステム上のレイヤーデータを確認するなら、<code class="language-plaintext highlighter-rouge">/var/lib/docker/&lt;storage-driver&gt;</code> の内容を一覧表示します。
以下は <code class="language-plaintext highlighter-rouge">overlay2</code> ストレージドライバーに対する例です。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /var/lib/docker/overlay2
16802227a96c24dcbeab5b37821e2b67a9f921749cd9a2e386d5a6d5bc6fc6d3
377d73dbb466e0bc7c9ee23166771b35ebdbe02ef17753d79fd3571d4ce659d7
3f02d96212b03e3383160d31d7c6aeca750d2d8a1879965b89fe8146594c453d
ec1ec45792908e90484f7e629330666e7eee599f08729c93890a7205a6ba35f5
l
</code></pre></div></div>

<p>ディレクトリ名はレイヤー ID に対応するものではありません。
（Docker 1.10 以前は対応づいていました。）</p>

<p>ここで 2 つの異なる Dockerfile を利用している状況を考えます。
1 つめの Dockerfile からは <code class="language-plaintext highlighter-rouge">acme/my-base-image:1.0</code> というイメージが作られるものとします。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:18.04</span>
<span class="k">COPY</span><span class="s"> . /app</span>
</code></pre></div></div>

<p>2 つめの Dockerfile は <code class="language-plaintext highlighter-rouge">acme/my-base-image:1.0</code> をベースとして、さらにレイヤーを追加するものとします。</p>

<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> acme/my-base-image:1.0</span>
<span class="k">CMD</span><span class="s"> /app/hello.sh</span>
</code></pre></div></div>

<p>2 つめのイメージには 1 つめのイメージが持つレイヤーがすべて含まれ、さらに <code class="language-plaintext highlighter-rouge">CMD</code> 命令による新たなレイヤーと、読み書き可能なコンテナーレイヤーが加わっています。
Docker にとって 1 つめのイメージにおけるレイヤーはすべて取得済であるため、再度プルによって取得する必要がありません。
2 つのイメージにおいて共通して存在しているレイヤーは、すべて共有します。</p>

<p>この 2 つの Dockerfile からイメージをビルドした場合、<code class="language-plaintext highlighter-rouge">docker image ls</code> や <code class="language-plaintext highlighter-rouge">docker history</code> コマンドを使ってみると、共有されているレイヤーに対する暗号化 ID は同一になっていることがわかります。</p>

<ol>
  <li>
    <p>新規に <code class="language-plaintext highlighter-rouge">cow-test/</code> というディレクトリを生成して移動します。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cow-test/</code> ディレクトリにて、以下の内容で新規ファイル <code class="language-plaintext highlighter-rouge">hello.sh</code> を生成します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
<span class="nb">echo</span> <span class="s2">"Hello world"</span>
</code></pre></div>    </div>

    <p>ファイルを保存して実行可能にします。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x hello.sh
</code></pre></div>    </div>
  </li>
  <li>
    <p>前述した 1 つめの Dockerfile の内容を、新規ファイル <code class="language-plaintext highlighter-rouge">Dockerfile.base</code> にコピーします。</p>
  </li>
  <li>
    <p>前述した 2 つめの Dockerfile の内容を、新規ファイル <code class="language-plaintext highlighter-rouge">Dockerfile</code> にコピーします。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cow-test/</code> ディレクトリ内にて 1 つめのイメージをビルドします。
コマンドでは最後の <code class="language-plaintext highlighter-rouge">.</code> を記述するのを忘れないでください。
これは <code class="language-plaintext highlighter-rouge">PATH</code> を指定するものであり、イメージに対してファイルの追加が必要となる場合に、そのファイルを探し出す場所を Docker に指示するものです。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> acme/my-base-image:1.0 <span class="nt">-f</span> Dockerfile.base <span class="nb">.</span>
Sending build context to Docker daemon  812.4MB
Step 1/2 : FROM ubuntu:18.04
 <span class="nt">---</span><span class="o">&gt;</span> d131e0fa2585
Step 2/2 : COPY <span class="nb">.</span> /app
 <span class="nt">---</span><span class="o">&gt;</span> Using cache
 <span class="nt">---</span><span class="o">&gt;</span> bd09118bcef6
Successfully built bd09118bcef6
Successfully tagged acme/my-base-image:1.0
</code></pre></div>    </div>
  </li>
  <li>
    <p>2 つめのイメージをビルドします。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> acme/my-final-image:1.0 <span class="nt">-f</span> Dockerfile <span class="nb">.</span>

Sending build context to Docker daemon  4.096kB
Step 1/2 : FROM acme/my-base-image:1.0
 <span class="nt">---</span><span class="o">&gt;</span> bd09118bcef6
Step 2/2 : CMD /app/hello.sh
 <span class="nt">---</span><span class="o">&gt;</span> Running <span class="k">in </span>a07b694759ba
 <span class="nt">---</span><span class="o">&gt;</span> dbf995fc07ff
Removing intermediate container a07b694759ba
Successfully built dbf995fc07ff
Successfully tagged acme/my-final-image:1.0
</code></pre></div>    </div>
  </li>
  <li>
    <p>2 つのイメージのサイズを確認します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker image <span class="nb">ls

</span>REPOSITORY                         TAG                     IMAGE ID            CREATED             SIZE
acme/my-final-image                1.0                     dbf995fc07ff        58 seconds ago      103MB
acme/my-base-image                 1.0                     bd09118bcef6        3 minutes ago       103MB
</code></pre></div>    </div>
  </li>
  <li>
    <p>それぞれのイメージに含まれるレイヤーを確認します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">history </span>bd09118bcef6
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
bd09118bcef6        4 minutes ago       /bin/sh <span class="nt">-c</span> <span class="c">#(nop) COPY dir:35a7eb158c1504e...   100B</span>
d131e0fa2585        3 months ago        /bin/sh <span class="nt">-c</span> <span class="c">#(nop)  CMD ["/bin/bash"]            0B</span>
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="nb">mkdir</span> <span class="nt">-p</span> /run/systemd <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">'...   7B
&lt;missing&gt;           3 months ago        /bin/sh -c sed -i '</span>s/^#<span class="se">\s</span><span class="k">*</span><span class="se">\(</span>deb.<span class="k">*</span>universe<span class="se">\.</span>..   2.78kB
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="nb">rm</span> <span class="nt">-rf</span> /var/lib/apt/lists/<span class="k">*</span>          0B
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="nb">set</span> <span class="nt">-xe</span>   <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">'#!/bin/sh'</span> <span class="o">&gt;</span>...   745B
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="c">#(nop) ADD file:eef57983bd66e3a...   103MB</span>
</code></pre></div>    </div>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">history </span>dbf995fc07ff

IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
dbf995fc07ff        3 minutes ago       /bin/sh <span class="nt">-c</span> <span class="c">#(nop)  CMD ["/bin/sh" "-c" "/a...   0B</span>
bd09118bcef6        5 minutes ago       /bin/sh <span class="nt">-c</span> <span class="c">#(nop) COPY dir:35a7eb158c1504e...   100B</span>
d131e0fa2585        3 months ago        /bin/sh <span class="nt">-c</span> <span class="c">#(nop)  CMD ["/bin/bash"]            0B</span>
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="nb">mkdir</span> <span class="nt">-p</span> /run/systemd <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">'...   7B
&lt;missing&gt;           3 months ago        /bin/sh -c sed -i '</span>s/^#<span class="se">\s</span><span class="k">*</span><span class="se">\(</span>deb.<span class="k">*</span>universe<span class="se">\.</span>..   2.78kB
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="nb">rm</span> <span class="nt">-rf</span> /var/lib/apt/lists/<span class="k">*</span>          0B
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="nb">set</span> <span class="nt">-xe</span>   <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">'#!/bin/sh'</span> <span class="o">&gt;</span>...   745B
&lt;missing&gt;           3 months ago        /bin/sh <span class="nt">-c</span> <span class="c">#(nop) ADD file:eef57983bd66e3a...   103MB</span>
</code></pre></div>    </div>

    <p>ほぼすべてのレイヤーが同一であって、ただ 2 つめのイメージの最上位レイヤーだけが違うのがわかります。
これを除けば、すべてのレイヤーが 2 つのイメージ間で共有されているので、各レイヤーは <code class="language-plaintext highlighter-rouge">/var/lib/docker/</code> には一度しか保存されません。
新たにできたレイヤーは、まったくと言ってよいほどに容量をとっていません。
というのも、そのレイヤーは何かのファイルを変更するわけでなく、単にコマンドを実行するだけのものであるからです。</p>

    <blockquote>
      <p><strong>メモ</strong>: <code class="language-plaintext highlighter-rouge">docker history</code> の出力において <code class="language-plaintext highlighter-rouge">&lt;missing&gt;</code> として示される行は、そのレイヤーが他のシステムにおいてビルドされていることを示しています。
したがってローカルシステム上では利用することができません。
この表示は無視して構いません。</p>
    </blockquote>
  </li>
</ol>

<h3 id="copying-makes-containers-efficient">コピーによりコンテナーを効率的に</h3>

<p>コンテナーを起動すると、それまであったレイヤーの最上部に、書き込み可能な薄いコンテナーレイヤーが加えられます。
コンテナーがファイルシステムに対して行った変更は、すべてそこに保存されます。
コンテナーが変更を行っていないファイルは、その書き込みレイヤーにはコピーされません。
つまり書き込みレイヤーは、できるだけ容量が小さく抑えられることになります。</p>

<p>コンテナー内にあるファイルが修正されると、ストレージドライバーはコピーオンライト方式により動作します。
そこで実行される各処理は、ストレージドライバーによってさまざまです。
<code class="language-plaintext highlighter-rouge">aufs</code>, <code class="language-plaintext highlighter-rouge">overlay</code>, <code class="language-plaintext highlighter-rouge">overlay2</code> といったドライバーの場合、だいたい以下のような順にコピーオンライト方式による処理が行われます。</p>

<ul>
  <li>
    <p>更新するべきファイルをイメージレイヤー内から探します。
この処理は最新のレイヤーから始まって、ベースレイヤーに向けて順に降りていき、一度に 1 つのレイヤーを処理していきます。
ファイルが見つかるとこれをキャッシュに加えて、次回以降の処理スピードを上げることに備えます。</p>
  </li>
  <li>
    <p>見つかったファイルを初めてコピーするときには <code class="language-plaintext highlighter-rouge">copy_up</code> という処理が行われます。
これによってそのファイルをコンテナーの書き込みレイヤーにコピーします。</p>
  </li>
  <li>
    <p>修正が発生すると、コピーを行ったそのファイルが処理されます。
つまりコンテナーは、下位のレイヤー内に存在している読み込み専用のそのファイルを見にいくことはありません。</p>
  </li>
</ul>

<p>Btrfs, ZFS といったドライバーにおけるコピーオンライト方式は、これとは異なります。
そのようなドライバーが行う手法の詳細は、後述するそれぞれの詳細説明を参照してください。</p>

<p>データを大量に書き込むようなコンテナーは、そういった書き込みを行わないコンテナーに比べて、データ領域をより多く消費します。
コンテナーの最上位にある書き込み可能な薄いレイヤー上に対して、書き込み処理を行うことは、たいていが新たなデータ領域を必要とするためです。</p>

<blockquote>
  <p><strong>メモ</strong>: 書き込みが頻繁に行われるアプリケーションにおいては、コンテナー内にデータを保存するべきではありません。
かわりに Docker ボリュームを利用してください。
Docker ボリュームは起動されるコンテナーからは独立していて、効率的な入出力を行うように設計されています。
さらにボリュームは複数のコンテナー間での共有が可能であり、書き込みレイヤーのサイズを増加させることもありません。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">copy_up</code> 処理は際立った性能のオーバーヘッドを招きます。
このオーバーヘッドは、利用しているストレージドライバーによってさまざまです。
大容量ファイル、多数のレイヤー、深いディレクトリ階層といったものが、さらに影響します。
<code class="language-plaintext highlighter-rouge">copy_up</code> 処理は対象となるファイルが初めて修正されたときにだけ実行されるので、オーバーヘッドはそれでも最小限に抑えられています。</p>

<p>コピーオンライトが動作している様子を確認するため、以下の例においては、前述した <code class="language-plaintext highlighter-rouge">acme/my-final-image:1.0</code> イメージをベースとする 5 つのコンテナーを見ていきます。
そして各コンテナーがどれだけの容量を消費しているかを確認します。</p>

<blockquote>
  <p><strong>メモ</strong>: 以下の手順は Docker Desktop for Mac または Docker Desktop for Windows では動作しません。</p>
</blockquote>

<ol>
  <li>
    <p>Docker ホスト上の端末画面から、以下のような <code class="language-plaintext highlighter-rouge">docker run</code> コマンドを実行します。
各行の終わりには、各コンテナーの ID を入力します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-dit</span> <span class="nt">--name</span> my_container_1 acme/my-final-image:1.0 bash <span class="se">\</span>
  <span class="o">&amp;&amp;</span> docker run <span class="nt">-dit</span> <span class="nt">--name</span> my_container_2 acme/my-final-image:1.0 bash <span class="se">\</span>
  <span class="o">&amp;&amp;</span> docker run <span class="nt">-dit</span> <span class="nt">--name</span> my_container_3 acme/my-final-image:1.0 bash <span class="se">\</span>
  <span class="o">&amp;&amp;</span> docker run <span class="nt">-dit</span> <span class="nt">--name</span> my_container_4 acme/my-final-image:1.0 bash <span class="se">\</span>
  <span class="o">&amp;&amp;</span> docker run <span class="nt">-dit</span> <span class="nt">--name</span> my_container_5 acme/my-final-image:1.0 bash

  c36785c423ec7e0422b2af7364a7ba4da6146cbba7981a0951fcc3fa0430c409
  dcad7101795e4206e637d9358a818e5c32e13b349e62b00bf05cd5a4343ea513
  1e7264576d78a3134fbaf7829bc24b1d96017cf2bc046b7cd8b08b5775c33d0c
  38fa94212a419a082e6a6b87a8e2ec4a44dd327d7069b85892a707e3fc818544
  1a174fc216cccf18ec7d4fe14e008e30130b11ede0f0f94a87982e310cf2e765
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">docker ps</code> コマンドを実行して、5 つのコンテナーが実行中であることを確認します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CONTAINER ID      IMAGE                     COMMAND     CREATED              STATUS              PORTS      NAMES
1a174fc216cc      acme/my-final-image:1.0   <span class="s2">"bash"</span>      About a minute ago   Up About a minute              my_container_5
38fa94212a41      acme/my-final-image:1.0   <span class="s2">"bash"</span>      About a minute ago   Up About a minute              my_container_4
1e7264576d78      acme/my-final-image:1.0   <span class="s2">"bash"</span>      About a minute ago   Up About a minute              my_container_3
dcad7101795e      acme/my-final-image:1.0   <span class="s2">"bash"</span>      About a minute ago   Up About a minute              my_container_2
c36785c423ec      acme/my-final-image:1.0   <span class="s2">"bash"</span>      About a minute ago   Up About a minute              my_container_1
</code></pre></div>    </div>
  </li>
  <li>
    <p>ローカルの保存ディレクトリの内容を一覧表示します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo ls</span> /var/lib/docker/containers

1a174fc216cccf18ec7d4fe14e008e30130b11ede0f0f94a87982e310cf2e765
1e7264576d78a3134fbaf7829bc24b1d96017cf2bc046b7cd8b08b5775c33d0c
38fa94212a419a082e6a6b87a8e2ec4a44dd327d7069b85892a707e3fc818544
c36785c423ec7e0422b2af7364a7ba4da6146cbba7981a0951fcc3fa0430c409
dcad7101795e4206e637d9358a818e5c32e13b349e62b00bf05cd5a4343ea513
</code></pre></div>    </div>
  </li>
  <li>
    <p>各サイズを確認します。</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo du</span> <span class="nt">-sh</span> /var/lib/docker/containers/<span class="k">*</span>

32K  /var/lib/docker/containers/1a174fc216cccf18ec7d4fe14e008e30130b11ede0f0f94a87982e310cf2e765
32K  /var/lib/docker/containers/1e7264576d78a3134fbaf7829bc24b1d96017cf2bc046b7cd8b08b5775c33d0c
32K  /var/lib/docker/containers/38fa94212a419a082e6a6b87a8e2ec4a44dd327d7069b85892a707e3fc818544
32K  /var/lib/docker/containers/c36785c423ec7e0422b2af7364a7ba4da6146cbba7981a0951fcc3fa0430c409
32K  /var/lib/docker/containers/dcad7101795e4206e637d9358a818e5c32e13b349e62b00bf05cd5a4343ea513
</code></pre></div>    </div>

    <p>各コンテナーは、ファイルシステム上において 32k しか容量をとっていません。</p>
  </li>
</ol>

<p>コピーオンライト方式は容量を抑えるだけでなく、起動時間も節約します。
コンテナーを起動するとき（あるいは同一イメージからなる複数コンテナーを起動するとき）、Docker が必要とするのは、書き込み可能な薄いコンテナーレイヤーを生成することだけだからです。</p>

<p>仮に Docker が新たなコンテナーを起動するたびに、その元にあるイメージ層をすべてコピーしなければならないとしたら、起動時間やディスク容量は著しく増大しているはずです。
このことは仮想マシン技術において、複数の仮想ディスクが仮想マシン 1 つに対して動作している様子にも似ています。</p>

<h2 id="related-information">関連情報</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/storage/volumes/">ボリューム</a></li>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/select-storage-driver/">ストレージドライバーの選定</a></li>
</ul>
