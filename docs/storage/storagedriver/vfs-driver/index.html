<p>The VFS storage driver is not a union filesystem; instead, each layer is a
directory on disk, and there is no copy-on-write support. To create a new
layer, a “deep copy” is done of the previous layer. This leads to lower
performance and more space used on disk than other storage drivers. However, it
is robust, stable, and works in every environment. It can also be used as a
mechanism to verify other storage back-ends against, in a testing environment.</p>

<h2 id="configure-docker-with-the-vfs-storage-driver">Configure Docker with the <code class="language-plaintext highlighter-rouge">vfs</code> storage driver</h2>

<ol>
  <li>
    <p>Stop Docker.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>systemctl stop docker
</code></pre></div>    </div>
  </li>
  <li>
    <p>Edit <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code>. If it does not yet exist, create it. Assuming
that the file was empty, add the following contents.</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"storage-driver"</span><span class="p">:</span><span class="w"> </span><span class="s2">"vfs"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>

    <p>If you want to set a quota to control the maximum size the VFS storage
driver can use, set the <code class="language-plaintext highlighter-rouge">size</code> option on the <code class="language-plaintext highlighter-rouge">storage-opts</code> key. Quotas
are only supported in Docker 17.12 and higher.</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"storage-driver"</span><span class="p">:</span><span class="w"> </span><span class="s2">"vfs"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"storage-opts"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"size=256M"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>

    <p>Docker does not start if the <code class="language-plaintext highlighter-rouge">daemon.json</code> file contains badly-formed JSON.</p>
  </li>
  <li>
    <p>Start Docker.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>systemctl start docker
</code></pre></div>    </div>
  </li>
  <li>
    <p>Verify that the daemon is using the <code class="language-plaintext highlighter-rouge">vfs</code> storage driver.
Use the <code class="language-plaintext highlighter-rouge">docker info</code> command and look for <code class="language-plaintext highlighter-rouge">Storage Driver</code>.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker info

Storage Driver: vfs
...
</code></pre></div>    </div>
  </li>
</ol>

<p>Docker is now using the <code class="language-plaintext highlighter-rouge">vfs</code> storage driver. Docker has automatically
created the <code class="language-plaintext highlighter-rouge">/var/lib/docker/vfs/</code> directory, which contains all the layers
used by running containers.</p>

<h2 id="how-the-vfs-storage-driver-works">How the <code class="language-plaintext highlighter-rouge">vfs</code> storage driver works</h2>

<p>VFS is not a union filesystem. Instead, each image layer and the writable
container layer are represented on the Docker host as subdirectories within
<code class="language-plaintext highlighter-rouge">/var/lib/docker/</code>. The union mount provides the unified view of all layers. The
directory names do not directly correspond to the IDs of the layers themselves.</p>

<p>VFS does not support copy-on-write (COW), so each time a new layer is created,
it is a deep copy of its parent layer. These layers are all located under
<code class="language-plaintext highlighter-rouge">/var/lib/docker/vfs/dir/</code>.</p>

<h3 id="example-image-and-container-on-disk-constructs">Example: Image and container on-disk constructs</h3>

<p>The following <code class="language-plaintext highlighter-rouge">docker pull</code> command shows a Docker host downloading a Docker
image comprising five layers.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker pull ubuntu

Using default tag: latest
latest: Pulling from library/ubuntu
e0a742c2abfd: Pull <span class="nb">complete
</span>486cb8339a27: Pull <span class="nb">complete
</span>dc6f0d824617: Pull <span class="nb">complete
</span>4f7a5649a30e: Pull <span class="nb">complete
</span>672363445ad2: Pull <span class="nb">complete
</span>Digest: sha256:84c334414e2bfdcae99509a6add166bbb4fa4041dc3fa6af08046a66fed3005f
Status: Downloaded newer image <span class="k">for </span>ubuntu:latest
</code></pre></div></div>

<p>After pulling, each of these layers is represented as a subdirectory of
<code class="language-plaintext highlighter-rouge">/var/lib/docker/vfs/dir/</code>. The directory names do not correlate with the
image layer IDs shown in the <code class="language-plaintext highlighter-rouge">docker pull</code> command. To see the size taken up on
disk by each layer, you can use the <code class="language-plaintext highlighter-rouge">du -sh</code> command, which gives the size as a
human-readable value.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> /var/lib/docker/vfs/dir/

total 0
drwxr-xr-x.  2 root root  19 Aug  2 18:19 3262dfbe53dac3e1ab7dcc8ad5d8c4d586a11d2ac3c4234892e34bff7f6b821e
drwxr-xr-x. 21 root root 224 Aug  2 18:23 6af21814449345f55d88c403e66564faad965d6afa84b294ae6e740c9ded2561
drwxr-xr-x. 21 root root 224 Aug  2 18:23 6d3be4585ba32f9f5cbff0110e8d07aea5f5b9fbb1439677c27e7dfee263171c
drwxr-xr-x. 21 root root 224 Aug  2 18:23 9ecd2d88ca177413ab89f987e1507325285a7418fc76d0dcb4bc021447ba2bab
drwxr-xr-x. 21 root root 224 Aug  2 18:23 a292ac6341a65bf3a5da7b7c251e19de1294bd2ec32828de621d41c7ad31f895
drwxr-xr-x. 21 root root 224 Aug  2 18:23 e92be7a4a4e3ccbb7dd87695bca1a0ea373d4f673f455491b1342b33ed91446b
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">du</span> <span class="nt">-sh</span> /var/lib/docker/vfs/dir/<span class="k">*</span>

4.0K	/var/lib/docker/vfs/dir/3262dfbe53dac3e1ab7dcc8ad5d8c4d586a11d2ac3c4234892e34bff7f6b821e
125M	/var/lib/docker/vfs/dir/6af21814449345f55d88c403e66564faad965d6afa84b294ae6e740c9ded2561
104M	/var/lib/docker/vfs/dir/6d3be4585ba32f9f5cbff0110e8d07aea5f5b9fbb1439677c27e7dfee263171c
125M	/var/lib/docker/vfs/dir/9ecd2d88ca177413ab89f987e1507325285a7418fc76d0dcb4bc021447ba2bab
104M	/var/lib/docker/vfs/dir/a292ac6341a65bf3a5da7b7c251e19de1294bd2ec32828de621d41c7ad31f895
104M	/var/lib/docker/vfs/dir/e92be7a4a4e3ccbb7dd87695bca1a0ea373d4f673f455491b1342b33ed91446b
</code></pre></div></div>

<p>The above output shows that three layers each take 104M and two take 125M. These
directories have only small differences from each other, but take up nearly the
same amount of room on disk. This is one of the disadvantages of using the
<code class="language-plaintext highlighter-rouge">vfs</code> storage driver.</p>

<h2 id="related-information">Related information</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/">Understand images, containers, and storage drivers</a></li>
  <li><a href="/docs.docker.jp.onthefly/storage/storagedriver/select-storage-driver/">Select a storage driver</a></li>
</ul>

