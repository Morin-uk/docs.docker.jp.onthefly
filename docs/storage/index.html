
<p>コンテナー内に生成されたファイルは、デフォルトではすべて書き込み可能なコンテナーレイヤーに保存されます。
これは以下を意味します。</p>

<ul>
  <li>コンテナーが存在しなくなると、データを保持しておくことができなくなります。
そのデータをコンテナーの外部から取得したいと思っても、外部プロセスがこれを行うことは極めて困難になります。</li>
  <li>コンテナーの書き込み可能レイヤーは、コンテナーが稼動しているホストマシンに強く結び付けられています。
したがってその中のデータをどこかに移動させることは容易ではありません。</li>
  <li>コンテナーの書き込み可能レイヤーにデータを書き込むためには、ファイルシステムを管理する <a href="/storage/storagedriver/">ストレージドライバー</a> が必要になります。
このストレージドライバーは、Linux カーネルを利用してユニオンファイルシステム（union filesystem）を提供します。
この特別な抽象ファイルシステムは <strong>データボリューム</strong> に比べると性能が劣ります。
データボリュームであれば、ホストのファイルシステムに直接データを書き込むことができます。</li>
</ul>

<p>Docker コンテナーにおけるファイルをホストマシン上に保存する方法は 2 つあります。
これを行えば、コンテナーが停止した後にもデータを維持していくことができます。
その 2 つの方法とは <strong>ボリューム</strong> と <strong>バインドマウント</strong> です。
Linux 上において Docker を稼動していれば、さらに <strong>tmpfs マウント</strong> を用いることもできます。
Windows 上において Docker を稼動していれば、<strong>名前つきパイプ</strong>（named pipe）を用いることもできます。</p>

<p>データを保持するためのこの 2 つの方法について、さらに具体的に読み進めてください。</p>

<h2 id="choose-the-right-type-of-mount">適切なマウント方法の選定</h2>

<p>どの種類のマウント方法を選んだとしても、コンテナー内部からのデータの見え方は同じです。
そのデータはコンテナー内のファイルシステム上において、ディレクトリとして見えるか、あるいは個別のファイルとして見えます。</p>

<p>ボリューム、バインドマウント、<code class="language-plaintext highlighter-rouge">tmpfs</code> マウントにどのような違いがあるのかは、そのデータが Docker ホスト上のどこに保存されるかを考えてみると、わかりやすくなります。</p>

<p><img src="/docs.docker.jp.onthefly/storage/images/types-of-mounts.png" alt="マウントの種類と Docker ホスト上でのデータ保存場所" /></p>

<ul>
  <li>
    <p><strong>ボリューム</strong> はホストのファイルシステムの一部としてデータが保存されます。
そしてこれは <strong>Docker によって管理されます</strong>。
（Linux であれば <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/</code> に保存されます。）
Docker 以外のプロセスは、このファイルシステム上の保存場所に変更を行ってはなりません。
ボリュームは Docker においてデータを維持するための最良の方法です。</p>
  </li>
  <li>
    <p><strong>バインドマウント</strong> はホストシステム上の <strong>どこにでも</strong> 保存することができます。
それが重要なシステムファイルやディレクトリであってもかまいません。
Docker ホスト上の Docker に無関係なプロセスや Docker コンテナーであったとしても、これを修正することがいつでもできます。</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">tmpfs</code> マウント</strong> はホストシステムのメモリ上にのみ保存されます。
そしてホストシステムのファイルシステムに向けての書き込みを行うことはできません。</p>
  </li>
</ul>

<h3 id="more-details-about-mount-types">マウントタイプに関する詳細</h3>

<ul>
  <li>
    <p><strong><a href="/docs.docker.jp.onthefly/storage/volumes/">ボリューム</a></strong>:
Docker によって生成され管理されるものです。
ボリュームは <code class="language-plaintext highlighter-rouge">docker volume create</code> コマンドによって明示的に生成します。
あるいは Docker が、コンテナーやサービスの生成時にボリュームを生成します。</p>

    <p>ボリュームを生成した際には、Docker ホスト上のディレクトリにボリュームが保存されます。
このボリュームをコンテナーにマウントすると、そのディレクトリがコンテナー内にマウントされるものとなります。
このことは、バインドマウントが動作する様子と同様です。
ただしボリュームは Docker によって管理されるものであって、ホストマシンの主要な機能からは切り離されています。</p>

    <p>ボリュームは複数のコンテナーに対して同時にマウントすることができます。
たとえそのボリュームを利用するコンテナーが 1 つも実行されていなくても、ボリュームは Docker が利用できる状態にあって、自動的に削除されることはありません。
未使用のボリュームは <code class="language-plaintext highlighter-rouge">docker volume prune</code> によって削除することができます。</p>

    <p>ボリュームのマウントは、<strong>名前つき</strong>（named）か <strong>匿名</strong>（anonymous）のいずれかにより行われます。
匿名ボリュームがコンテナーにマウントされた初めての段階においては、明示的な名称がありません。
そこで Docker が、Docker ホスト内で必ず固有となるランダムな名称を与えます。
名前を持たないというだけで、名前つきと匿名の各ボリュームは同等に機能します。</p>

    <p>ボリュームでは <strong>ボリュームドライバー</strong> の利用がサポートされます。
これによって、いろいろな利用の仕方が可能となります。
たとえば手元のデータを、リモートホストやクラウドプロバイダーに保存することができるようになります。</p>
  </li>
  <li>
    <p><strong><a href="/docs.docker.jp.onthefly/storage/bind-mounts/">バインドマウント</a></strong>: Docker の初期の段階から利用可能。
バインドマウントにはボリュームに比べて機能が制限されています。
バインドマウントを利用する際には、<strong>ホストマシン</strong> 上のファイルやディレクトリがコンテナーにマウントされます。
そのファイルやディレクトリは、ホストマシン上のフルパスによって参照されます。
ファイルやディレクトリが、Docker ホスト上からなくなっていても問題ありません。
存在していないときは、処理実行時に生成されます。
バインドマウントは非常に効率的なものですが、ホストマシン上のファイルシステムに依存し、利用可能な所定のディレクトリ構造に従って動作します。
Docker アプリケーションを新規開発する際には、これではなく名前つきボリュームを利用することを考えてみてください。
バインドマウントを直接管理するような Docker CLI コマンドはありません。</p>

    <blockquote class="important">
      <p>バインドマウントは機密ファイルへのアクセスも行います。</p>

      <p>バインドマウントを利用する際の副作用として、これが良いことか悪いことかはわかりませんが、<strong>コンテナー</strong> 内に動作するプロセスを通じて <strong>ホスト</strong> のファイルシステムに変更がかけられるということです。
たとえばシステムにとって重要なファイル、ディレクトリを生成、編集、削除ができてしまいます。
セキュリティに影響を及ぼしかねない強力な能力がここにあって、ホストシステム上の Docker 以外のプロセスへも影響します。</p>
    </blockquote>
  </li>
  <li>
    <p><strong><a href="/docs.docker.jp.onthefly/storage/tmpfs/">tmpfs マウント</a></strong>: <code class="language-plaintext highlighter-rouge">tmpfs</code> マウントとは、Docker ホスト上もコンテナー上も、ディスクに長らく保持されるものではありません。
これはコンテナーが起動している間のみ、コンテナーが利用するものであって、一時的な状態や機密情報などを保存します。
たとえば Docker 内部においては、Swarm サービスが <code class="language-plaintext highlighter-rouge">tmpfs</code> マウントを利用して、サービスコンテナー内に <a href="/docs.docker.jp.onthefly/engine/swarm/secrets/">secrets</a> をマウントしています。</p>
  </li>
  <li>
    <p><strong><a href="https://docs.microsoft.com/en-us/windows/desktop/ipc/named-pipes">名前つきパイプ</a></strong>（named pipe）:
<code class="language-plaintext highlighter-rouge">npipe</code> マウントは Docker ホストとコンテナーの間での通信のために利用されます。
よく行われる利用例としては、コンテナー内部にサードパーティー製のツールを実行させて、名前つきパイプにより Docker Engine API への接続を行うような場合です。</p>
  </li>
</ul>

<p>バインドマウントとボリュームは <code class="language-plaintext highlighter-rouge">-v</code> または <code class="language-plaintext highlighter-rouge">--volume</code> フラグを使って、コンテナーへのマウントを行うことができます。
しかしその文法は多少異なります。
<code class="language-plaintext highlighter-rouge">tmpfs</code> マウントの場合は <code class="language-plaintext highlighter-rouge">--tmpfs</code> フラグを使います。
ただし Docker 17.06 およびそれ以降においては、コンテナーとサービスの双方において、バインドマウント、ボリューム、<code class="language-plaintext highlighter-rouge">tmpfs</code> マウントのどれであっても、<code class="language-plaintext highlighter-rouge">--mount</code> フラグを利用することが推奨されます。
文法がよりはっきりとしているからです。</p>

<h2 id="good-use-cases-for-volumes">ボリュームの適切な利用例</h2>

<p>Docker コンテナーやサービスにおいてデータを保持するためには、ボリュームを用いるのが好ましい方法です。
ボリュームの利用例として以下のものがあります。</p>

<ul>
  <li>
    <p>複数コンテナーを起動し、データ共有を行う場合です。
ボリュームが明示的に生成されていない場合、コンテナーへのマウント時の初回にボリュームは生成されます。
コンテナーが停止されるか削除されたとしても、ボリュームは残ります。
複数コンテナーは同一ボリュームを同時にマウントすることが可能です。
その場合、読み書き可能、あるいは読み込み専用とすることができます。
ボリュームは、明示的に削除を指示したときのみ削除されます。</p>
  </li>
  <li>
    <p>Docker ホストにおいて、指定されたディレクトリまたはファイル構造が保証されていない場合です。
ボリュームを用いることで、Docker ホストの設定を、コンテナーの実行環境から切り離すことができます。</p>
  </li>
  <li>
    <p>コンテナーデータの保存先として、ローカルマシンではなく、リモートホストやクラウドプロバイダーを利用したい場合です。</p>
  </li>
  <li>
    <p>1 つの Docker ホストのデータをバックアップして、他のホストに復元、移行する必要がある場合です。
こういった場合にボリュームを選びます。
ボリュームを利用しているコンテナーを停止させてから、ボリュームがあるディレクトリのバックアップをとります（ディレクトリは <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/&lt;ボリューム名&gt;</code> などです）。</p>
  </li>
  <li>
    <p>Docker Desktop においてアプリケーションが高性能な I/O を必要とする場合です。
ボリュームはホスト上ではなく Linux VM 上に保存されます。
このことはつまり、読み書きにおける待ち時間がより少なくなり、スループットが向上します。</p>
  </li>
  <li>
    <p>Docker Desktop 上でのアプリケーションが、完全にネイティブなファイルシステムの動作を必要とする場合です。
たとえばデータベースエンジンでは、トランザクションの耐久性を保証するために、ディスクへの書き込みを細かく制御できることが必要になります。
ボリュームは Linux VM 上に保存され、これらを保証することができます。
一方バインドマウントは macOS や Windows にリモート接続されるものなので、ファイルシステムの動作は若干異なるものになります。</p>
  </li>
</ul>

<h2 id="good-use-cases-for-bind-mounts">バインドマウントの適切な利用例</h2>

<p>一般的には、可能なかぎりボリュームを用いるべきです。
バインドマウントは、以下のような利用例において適切と考えられます。</p>

<ul>
  <li>
    <p>設定ファイルをホストマシンからコンテナーに共有するような場合です。
デフォルトで Docker はコンテナーに対し DNS 解決機能を提供しますが、それがこの状況に相当します。
この場合、<code class="language-plaintext highlighter-rouge">/etc/resolv.conf</code> をホストマシンから各コンテナーへマウントすることを行います。</p>
  </li>
  <li>
    <p>ソースコードやビルド結果を、Docker ホスト上の開発環境とコンテナーとの間で共有する場合です。
たとえば Maven の <code class="language-plaintext highlighter-rouge">target/</code> ディレクトリをコンテナーにマウントします。
Docker ホスト上にて Maven プロジェクトをビルドするたびに、コンテナーは再ビルドされた結果をすぐに利用します。</p>

    <p>Docker をこのようにして開発に利用する場合、本番環境用の Dockerfile には、本番向けにビルドされたバイナリを、直接イメージにコピーするような記述を行うはずです。
そこではもう、バインドマウントに頼ることはありません。</p>
  </li>
  <li>
    <p>Docker ホストのファイルやディレクトリ構造が、コンテナーにとって必要となるバインドマウントと合致することが保証されている場合です。</p>
  </li>
</ul>

<h2 id="good-use-cases-for-tmpfs-mounts">tmpfs マウントの適切な利用例</h2>

<p><code class="language-plaintext highlighter-rouge">tmpfs</code> マウントの一番の使い方は、ホストマシン上にもコンテナー内にも、データを残しておきたくない場合に利用することです。
セキュリティに関する理由もありますが、アプリケーションが書き込むデータが大量にあって、それが保存を必要としないのであれば、コンテナーの性能を保護する目的があります。</p>

<h2 id="tips-for-using-bind-mounts-or-volumes">バインドマウントとボリュームを使う際のヒント</h2>

<p>バインドマウントとボリュームのどちらかを用いる場合には、以下のことを忘れないでください。</p>

<ul>
  <li>
    <p>コンテナー内のディレクトリに <strong>空のボリューム</strong> をマウントしようとしていて、そのディレクトリ内にファイルやディレクトリが存在する場合、そのファイルやディレクトリはボリューム内にコピーされます。
コンテナー起動時に指定したボリュームがまだ存在していなかった場合は、空のボリュームが生成されます。
コンテナーの求めに応じて事前にデータを提供しておく方法として用いられます。</p>
  </li>
  <li>
    <p>コンテナー内のディレクトリに <strong>バインドマウントか、空ではないボリューム</strong> をマウントしようとしていて、そのディレクトリ内にファイルやディレクトリが存在する場合、マウントによってそのファイルやディレクトリは隠れてしまいます。
それはたとえば、Linux マシン上の <code class="language-plaintext highlighter-rouge">/mnt</code> にファイルを保存した後に、<code class="language-plaintext highlighter-rouge">/mnt</code> に対して USB ドライブをマウントしたような場合と同じです。
<code class="language-plaintext highlighter-rouge">/mnt</code> に存在していた内容は USB ドライブの内容によって隠されてしまい、USB ドライブがアンマウントされるまで続きます。
隠されてしまったファイルは、削除されるわけでなく変更もされません。
しかしバインドマウントやボリュームがアンマウントされない限り、アクセスすることはできません。</p>
  </li>
</ul>

<h2 id="next-steps">次のステップ</h2>

<ul>
  <li><a href="/docs.docker.jp.onthefly/storage/volumes/">ボリューム</a> について学ぶ。</li>
  <li><a href="/docs.docker.jp.onthefly/storage/bind-mounts/">バインドマウント</a> について学ぶ。</li>
  <li><a href="/docs.docker.jp.onthefly/storage/tmpfs/">tmpfs マウント</a> について学ぶ。</li>
  <li><a href="/storage/storagedriver/">ストレージドライバー</a> について学ぶ。
これはバインドマウントやボリュームに関連するものではありませんが、
コンテナーの書き込み可能レイヤーにデータを保存できるものです。</li>
</ul>
